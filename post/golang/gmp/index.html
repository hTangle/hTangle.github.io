<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>GMP调度原理 - HLDay</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="hlday" /><meta name="description" content="Goroutine 调度器过程及原理" /><meta name="keywords" content="hlday, blog, go, python, linux, shell" />





<script async src="https://www.googletagmanager.com/gtag/js?id=G-59Y2CYW544"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-59Y2CYW544');
</script>

<meta name="generator" content="Hugo 0.93.2 with theme even" />


<link rel="canonical" href="/post/golang/gmp/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">



<meta property="og:title" content="GMP调度原理" />
<meta property="og:description" content="Goroutine 调度器过程及原理" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/golang/gmp/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-03-09T20:59:22+08:00" />
<meta property="article:modified_time" content="2022-03-09T20:59:22+08:00" />

<meta itemprop="name" content="GMP调度原理">
<meta itemprop="description" content="Goroutine 调度器过程及原理"><meta itemprop="datePublished" content="2022-03-09T20:59:22+08:00" />
<meta itemprop="dateModified" content="2022-03-09T20:59:22+08:00" />
<meta itemprop="wordCount" content="11573">
<meta itemprop="keywords" content="go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="GMP调度原理"/>
<meta name="twitter:description" content="Goroutine 调度器过程及原理"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">HLDay</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/image/bing">
        <li class="mobile-menu-item">BingDailyPicture</li>
      </a><a href="/post/preview/">
        <li class="mobile-menu-item">Share</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel" style="max-width: 75%; width: 70% !important;">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">HLDay</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/image/bing">BingDailyPicture</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/preview/">Share</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">GMP调度原理</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-03-09 </span>
        <div class="post-category">
            <a href="/categories/go/"> go </a>
            </div>
          <span class="more-meta"> 11573 words </span>
          <span class="more-meta"> 24 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc" style="position: fixed !important;width:14%;top:10%;right: 1% !important;">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#数据结构">数据结构</a>
          <ul>
            <li><a href="#g">G</a></li>
            <li><a href="#m">M</a></li>
            <li><a href="#p">P</a></li>
          </ul>
        </li>
        <li><a href="#原理">原理</a>
          <ul>
            <li><a href="#单线程调度器">单线程调度器</a></li>
            <li><a href="#多线程调度器">多线程调度器</a></li>
            <li><a href="#任务窃取调度器">任务窃取调度器</a></li>
            <li><a href="#抢占式调度">抢占式调度</a></li>
          </ul>
        </li>
        <li><a href="#调度器启动">调度器启动</a></li>
        <li><a href="#创建-goroutine">创建 Goroutine</a>
          <ul>
            <li><a href="#初始化结构体">初始化结构体</a></li>
            <li><a href="#运行队列">运行队列</a></li>
            <li><a href="#调度信息">调度信息</a></li>
          </ul>
        </li>
        <li><a href="#循环调度">循环调度</a></li>
        <li><a href="#触发调度">触发调度</a>
          <ul>
            <li><a href="#主动挂起">主动挂起</a></li>
            <li><a href="#系统调用">系统调用</a></li>
            <li><a href="#协作式调度">协作式调度</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <ul>
<li>
<p>G是goroutine实现的核心结构，它包含了栈，指令指针，以及其他对调度goroutine很重要的信息，例如其阻塞的channel。表示 Goroutine，它是一个待执行的任务</p>
</li>
<li>
<p><code>M结构是Machine，系统线程</code>，它由操作系统管理，goroutine就是跑在M之上的；M是一个很大的结构，里面维护小对象内存cache（mcache）、当前执行的goroutine、随机数发生器等等非常多的信息。M的PC寄存器会执行G提供的函数。表示操作系统的线程，它由操作系统的调度器调度和管理；</p>
</li>
<li>
<p>P结构是Processor，处理器</p>
<p>，它的主要用途就是用来执行goroutine，它维护了一个goroutine队列，即runqueue。Processor的让我们从N:1调度到M:N调度的重要部分。</p>
<p>表示处理器，它可以被看做运行在线程上的本地调度器；</p>
<ul>
<li>本地队列：本地的队列是无锁的，没有数据竞争问题，处理速度比较高；</li>
<li>全局队列：是用来平衡不同的P的任务数量，所有的M共享P的全局队列。</li>
</ul>
</li>
</ul>
<blockquote>
<p>Processor的数量是在启动时被设置为环境变量GOMAXPROCS的值，或者通过运行时调度函数GOMAXPROCS()进行设置。Processor数量固定意味着任意时刻只有GOMAXPROCS个线程在运行着go代码</p>
</blockquote>
<blockquote>
<p>进程，线程和协程的区别</p>
<ol>
<li>进程：系统进行资源分配的基本单位，每个进程有独立且隔离的内存空间；</li>
<li>线程：线程是CPU调度的基本单位，线程依赖于进程的存在，每个线程会共享父进程的资源；</li>
<li>协程：用户态的轻量级线程，协程的调度完全由用户控制，协程切换只需要保存任务的上下文，没有内核开销</li>
</ol>
</blockquote>
<h2 id="数据结构">数据结构</h2>
<h3 id="g">G</h3>
<p>Goroutine 是 Go 语言调度器中待执行的任务，它在运行时调度器中的地位与线程在操作系统中差不多，但是它占用了更小的内存空间，也降低了上下文切换的开销。</p>
<p>Goroutine 只存在于 Go 语言的运行时，它是 Go 语言在用户态提供的线程，作为一种粒度更细的资源调度单元，如果使用得当能够在高并发的场景下更高效地利用机器的 CPU。</p>
<p>Goroutine 在 Go 语言运行时使用私有结构体<a href="https://draveness.me/golang/tree/runtime.g"> <code>runtime.g</code></a> 表示。这个私有结构体非常复杂，总共包含 40 多个用于表示各种状态的成员变量</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">g</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stack</span>       <span class="nx">stack</span>
</span></span><span class="line"><span class="cl">        <span class="nx">stackguard0</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl">        <span class="nx">preempt</span>       <span class="kt">bool</span> <span class="c1">// 抢占信号
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">preemptStop</span>   <span class="kt">bool</span> <span class="c1">// 抢占时将状态修改成 `_Gpreempted`
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">preemptShrink</span> <span class="kt">bool</span> <span class="c1">// 在同步安全点收缩栈
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_panic</span>       <span class="o">*</span><span class="nx">_panic</span> <span class="c1">// 最内侧的 panic 结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">_defer</span>       <span class="o">*</span><span class="nx">_defer</span> <span class="c1">// 最内侧的延迟函数结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">m</span>              <span class="o">*</span><span class="nx">m</span>  <span class="c1">// 当前 Goroutine 占用的线程，可能为空；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sched</span>          <span class="nx">gobuf</span> <span class="c1">// 存储 Goroutine 的调度相关的数据；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">atomicstatus</span>   <span class="kt">uint32</span> <span class="c1">//Goroutine 的状态；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">goid</span>           <span class="kt">int64</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">gobuf</span> <span class="kd">struct</span> <span class="p">{</span> <span class="c1">//在调度器保存或者恢复上下文的时候用到，其中的栈指针和程序计数器会用来存储或者恢复寄存器中的值，改变程序即将执行的代码。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">sp</span>   <span class="kt">uintptr</span> <span class="c1">//栈指针
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">pc</span>   <span class="kt">uintptr</span> <span class="c1">//程序计数器；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">g</span>    <span class="nx">guintptr</span> <span class="c1">// 持有 runtime.gobuf 的 Goroutine；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>        <span class="nx">ret</span>  <span class="nx">sys</span><span class="p">.</span><span class="nx">Uintreg</span> <span class="c1">// 系统调用的返回值；
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 <code>stack</code> 字段描述了当前 Goroutine 的栈内存范围 [stack.lo, stack.hi)，另一个字段 <code>stackguard0</code> 可以用于调度器抢占式调度。除了 <code>stackguard0</code> 之外，Goroutine 中还包含另外三个与抢占密切相关的字段：preempt、preemptStop、preemptShrink</p>
<p>结构体 <a href="https://draveness.me/golang/tree/runtime.g"><code>runtime.g</code></a> 的 <code>atomicstatus</code> 字段存储了当前 Goroutine 的状态。除了几个已经不被使用的以及与 GC 相关的状态之外，Goroutine 可能处于以下 9 种状态：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_Gidle</code></td>
<td>刚刚被分配并且还没有被初始化</td>
</tr>
<tr>
<td><code>_Grunnable</code></td>
<td>没有执行代码，没有栈的所有权，存储在运行队列中</td>
</tr>
<tr>
<td><code>_Grunning</code></td>
<td>可以执行代码，拥有栈的所有权，被赋予了内核线程 M 和处理器 P</td>
</tr>
<tr>
<td><code>_Gsyscall</code></td>
<td>正在执行系统调用，拥有栈的所有权，没有执行用户代码，被赋予了内核线程 M 但是不在运行队列上</td>
</tr>
<tr>
<td><code>_Gwaiting</code></td>
<td>由于运行时而被阻塞，没有执行用户代码并且不在运行队列上，但是可能存在于 Channel 的等待队列上</td>
</tr>
<tr>
<td><code>_Gdead</code></td>
<td>没有被使用，没有执行代码，可能有分配的栈</td>
</tr>
<tr>
<td><code>_Gcopystack</code></td>
<td>栈正在被拷贝，没有执行代码，不在运行队列上</td>
</tr>
<tr>
<td><code>_Gpreempted</code></td>
<td>由于抢占而被阻塞，没有执行用户代码并且不在运行队列上，等待唤醒</td>
</tr>
<tr>
<td><code>_Gscan</code></td>
<td>GC 正在扫描栈空间，没有执行代码，可以与其他状态同时存在</td>
</tr>
</tbody>
</table>
<p>虽然 Goroutine 在运行时中定义的状态非常多而且复杂，但是我们可以将这些不同的状态聚合成三种：等待中、可运行、运行中，运行期间会在这三种状态来回切换：</p>
<ul>
<li>等待中：Goroutine 正在等待某些条件满足，例如：系统调用结束等，包括 <code>_Gwaiting</code>、<code>_Gsyscall</code> 和 <code>_Gpreempted</code> 几个状态；</li>
<li>可运行：Goroutine 已经准备就绪，可以在线程运行，如果当前程序中有非常多的 Goroutine，每个 Goroutine 就可能会等待更多的时间，即 <code>_Grunnable</code>；</li>
<li>运行中：Goroutine 正在某个线程上运行，即 <code>_Grunning</code>；</li>
</ul>
<h3 id="m">M</h3>
<p>Go 语言并发模型中的 M 是操作系统线程。调度器最多可以创建 10000 个线程，但是其中大多数的线程都不会执行用户代码（可能陷入系统调用），最多只会有 <code>GOMAXPROCS</code> 个活跃线程能够正常运行。</p>
<p>在默认情况下，运行时会将 <code>GOMAXPROCS</code> 设置成当前机器的核数，我们也可以在程序中使用 <a href="https://draveness.me/golang/tree/runtime.GOMAXPROCS"><code>runtime.GOMAXPROCS</code></a> 来改变最大的活跃线程数。</p>
<p>在大多数情况下，我们都会使用 Go 的默认设置，也就是线程数等于 CPU 数，默认的设置不会频繁触发操作系统的线程调度和上下文切换，所有的调度都会发生在用户态，由 Go 语言调度器触发，能够减少很多额外开销。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">m</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">g0</span>   <span class="o">*</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">        <span class="nx">curg</span> <span class="o">*</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">        <span class="nx">p</span>             <span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl">        <span class="nx">nextp</span>         <span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl">        <span class="nx">oldp</span>          <span class="nx">puintptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中 g0 是持有调度栈的 Goroutine，<code>curg</code> 是在当前线程上运行的用户 Goroutine，这也是操作系统线程唯一关心的两个 Goroutine。</p>
<p>g0 是一个运行时中比较特殊的 Goroutine，它会深度参与运行时的调度过程，包括 Goroutine 的创建、大内存分配和 CGO 函数的执行。在后面的小节中，我们会经常看到 g0 的身影。</p>
<p>还存在三个与处理器相关的字段，它们分别表示正在运行代码的处理器 <code>p</code>、暂存的处理器 <code>nextp</code> 和执行系统调用之前使用线程的处理器 <code>oldp</code></p>
<h3 id="p">P</h3>
<p>调度器中的处理器 P 是线程和 Goroutine 的中间层，它能提供线程需要的上下文环境，也会负责调度线程上的等待队列，通过处理器 P 的调度，每一个内核线程都能够执行多个 Goroutine，它能在 Goroutine 进行一些 I/O 操作时及时让出计算资源，提高线程的利用率。</p>
<p>因为调度器在启动时就会创建 <code>GOMAXPROCS</code> 个处理器，所以 Go 语言程序的处理器数量一定会等于 <code>GOMAXPROCS</code>，这些处理器会绑定到不同的内核线程上。</p>
<p><code>runtime.p</code> 是处理器的运行时表示，作为调度器的内部实现，它包含的字段也非常多，其中包括与性能追踪、垃圾回收和计时器相关的字段，这些字段也非常重要，但是在这里就不展示了，我们主要关注处理器中的线程和运行队列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">p</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nx">m</span>           <span class="nx">muintptr</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="nx">runqhead</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">        <span class="nx">runqtail</span> <span class="kt">uint32</span>
</span></span><span class="line"><span class="cl">        <span class="nx">runq</span>     <span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">        <span class="nx">runnext</span> <span class="nx">guintptr</span>
</span></span><span class="line"><span class="cl">        <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>反向存储的线程维护着线程与处理器之间的关系，而 <code>runqhead</code>、<code>runqtail</code> 和 <code>runq</code> 三个字段表示处理器持有的运行队列，其中存储着待执行的 Goroutine 列表，<code>runnext</code> 中是线程下一个需要执行的 Goroutine。</p>
<p><a href="https://draveness.me/golang/tree/runtime.p"><code>runtime.p</code></a> 结构体中的状态 <code>status</code> 字段会是以下五种中的一种：</p>
<table>
<thead>
<tr>
<th>状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>_Pidle</code></td>
<td>处理器没有运行用户代码或者调度器，被空闲队列或者改变其状态的结构持有，运行队列为空</td>
</tr>
<tr>
<td><code>_Prunning</code></td>
<td>被线程 M 持有，并且正在执行用户代码或者调度器</td>
</tr>
<tr>
<td><code>_Psyscall</code></td>
<td>没有执行用户代码，当前线程陷入系统调用</td>
</tr>
<tr>
<td><code>_Pgcstop</code></td>
<td>被线程 M 持有，当前处理器由于垃圾回收被停止</td>
</tr>
<tr>
<td><code>_Pdead</code></td>
<td>当前处理器已经不被使用</td>
</tr>
</tbody>
</table>
<p>通过分析处理器 P 的状态，我们能够对处理器的工作过程有一些简单理解，例如处理器在执行用户代码时会处于 <code>_Prunning</code> 状态，在当前线程执行 I/O 操作时会陷入 <code>_Psyscall</code> 状态。</p>
<h2 id="原理">原理</h2>
<h3 id="单线程调度器">单线程调度器</h3>
<p>0.x 版本调度器只包含表示 Goroutine 的 G 和表示线程的 M 两种结构，全局也只有一个线程。我们可以在 <a href="https://github.com/golang/go/commit/96824000ed89d13665f6f24ddc10b3bf812e7f47">clean up scheduler</a> 提交中找到单线程调度器的源代码，在这时 Go 语言的调度器还是由 C 语言实现的，调度函数 <code>runtime.scheduler:9682400</code> 也只包含 40 多行代码 ：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">scheduler</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">G</span><span class="o">*</span> <span class="n">gp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">gosave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">m</span><span class="o">-&gt;</span><span class="n">sched</span><span class="p">)){</span>
</span></span><span class="line"><span class="cl">                <span class="n">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sched</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="n">gp</span> <span class="o">=</span> <span class="n">m</span><span class="o">-&gt;</span><span class="n">curg</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">switch</span><span class="p">(</span><span class="n">gp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="nl">Grunnable</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="nl">Grunning</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="n">gp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">Grunnable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">gput</span><span class="p">(</span><span class="n">gp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="p">...</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">                <span class="n">notewakeup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gp</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">        <span class="n">gp</span> <span class="o">=</span> <span class="n">nextgandunlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">noteclear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gp</span><span class="o">-&gt;</span><span class="n">stopped</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">        <span class="n">gp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">Grunning</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="o">-&gt;</span><span class="n">curg</span> <span class="o">=</span> <span class="n">gp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">g</span> <span class="o">=</span> <span class="n">gp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gp</span><span class="o">-&gt;</span><span class="n">sched</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数会遵循如下的过程调度 Goroutine：</p>
<ol>
<li>获取调度器的全局锁；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.gosave:9682400"><code>runtime.gosave:9682400</code> </a>保存栈寄存器和程序计数器；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.nextgandunlock:9682400"><code>runtime.nextgandunlock:9682400</code></a> 获取下一个需要运行的 Goroutine 并解锁调度器；</li>
<li>修改全局线程 <code>m</code> 上要执行的 Goroutine；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.gogo:9682400">runtime.gogo:9682400</a> 函数运行最新的 Goroutine；</li>
</ol>
<p>虽然这个单线程调度器的唯一优点就是<strong>能运行</strong>，但是这次提交已经包含了 G 和 M 两个重要的数据结构，也建立了 Go 语言调度器的框架。</p>
<h3 id="多线程调度器">多线程调度器</h3>
<p>Go 语言在 1.0 版本正式发布时就支持了多线程的调度器，与上一个版本几乎不可用的调度器相比，Go 语言团队在这一阶段实现了从不可用到可用的跨越。我们可以在 <a href="https://github.com/golang/go/blob/go1.0.1/src/pkg/runtime/proc.c"><code>pkg/runtime/proc.c</code> </a>文件中找到 1.0.1 版本的调度器，多线程版本的调度函数<a href="https://draveness.me/golang/tree/runtime.schedule:go1.0.1"> <code>runtime.schedule:go1.0.1</code> </a>包含 70 多行代码，我们在这里保留了该函数的核心逻辑：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">static</span> <span class="kt">void</span> <span class="nf">schedule</span><span class="p">(</span><span class="n">G</span> <span class="o">*</span><span class="n">gp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="n">schedlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">if</span><span class="p">(</span><span class="n">gp</span> <span class="o">!=</span> <span class="n">nil</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="n">gp</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="n">nil</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="n">uint32</span> <span class="n">v</span> <span class="o">=</span> <span class="n">runtime</span><span class="err">·</span><span class="n">xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="n">runtime</span><span class="err">·</span><span class="n">sched</span><span class="p">.</span><span class="n">atomic</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="n">mcpuShift</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                <span class="k">if</span><span class="p">(</span><span class="n">atomic_mcpu</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">maxgomaxprocs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">                        <span class="n">runtime</span><span class="err">·</span><span class="n">throw</span><span class="p">(</span><span class="s">&#34;negative mcpu in scheduler&#34;</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">                <span class="k">switch</span><span class="p">(</span><span class="n">gp</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">){</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="nl">Grunning</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">                        <span class="n">gp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">Grunnable</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                        <span class="n">gput</span><span class="p">(</span><span class="n">gp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">                        <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">                <span class="k">case</span> <span class="p">...</span><span class="o">:</span>
</span></span><span class="line"><span class="cl">                <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">                <span class="p">...</span>
</span></span><span class="line"><span class="cl">        <span class="p">}</span>
</span></span><span class="line"><span class="cl">        <span class="n">gp</span> <span class="o">=</span> <span class="n">nextgandunlock</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="n">gp</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">Grunning</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">m</span><span class="o">-&gt;</span><span class="n">curg</span> <span class="o">=</span> <span class="n">gp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">gp</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">        <span class="n">runtime</span><span class="err">·</span><span class="n">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gp</span><span class="o">-&gt;</span><span class="n">sched</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>整体的逻辑与单线程调度器没有太多区别，因为我们的程序中可能同时存在多个活跃线程，所以多线程调度器引入了 <code>GOMAXPROCS</code> 变量帮助我们灵活控制程序中的最大处理器数，即活跃线程数。</p>
<p>多线程调度器的主要问题是调度时的锁竞争会严重浪费资源，<a href="http://golang.org/s/go11sched">Scalable Go Scheduler Design Doc</a> 中对调度器做的性能测试发现 14% 的时间都花费在 <a href="https://draveness.me/golang/tree/runtime.futex:go1.0.1"><code>runtime.futex:go1.0.1</code> </a>上，该调度器有以下问题需要解决：</p>
<ol>
<li>调度器和锁是全局资源，所有的调度状态都是中心化存储的，锁竞争问题严重；</li>
<li>线程需要经常互相传递可运行的 Goroutine，引入了大量的延迟；</li>
<li>每个线程都需要处理内存缓存，导致大量的内存占用并影响数据局部性；</li>
<li>系统调用频繁阻塞和解除阻塞正在运行的线程，增加了额外开销；</li>
</ol>
<blockquote>
<ul>
<li>io 与系统调用不能混淆，一个 io 过程可能包括多次系统调用。</li>
<li>（经过一个系统调用发现文件描述符还未可用而）阻塞的 io 首先会导致 G 的挂起，此时 G 与 M 分离，且不在任何 P 的运行队列中，当前的 P 会调度下一个 G，这个阶段不涉及新线程的创建。</li>
<li>被 io 挂起的 G 由网络轮询器维护，直到文件描述符可用。</li>
<li>网络轮询器既会被（在独立线程中的）系统监控 Goroutine 触发，也会被其他各个活跃线程上的 Goroutine 触发。</li>
<li>当文件描述符可用时，G 会重新加入到原来的 P 中等待被调度。</li>
<li>当 G 被重新调度时，会重新发起读/写系统调用。</li>
<li>当 G 进行系统调用的时候，对应的 M 和 P 也阻塞在系统调用，并不会立刻发生抢占，只有当这个阻塞持续时间过长（10 ms）时，才会将 P（及之上的其他 G）抢占并分配到空闲的 M 上，此时如果没有空闲的，才会创建新的线程。</li>
</ul>
<p>通过以上过程可见，密集的 io 通常并不会产生过多的线程。</p>
</blockquote>
<h3 id="任务窃取调度器">任务窃取调度器</h3>
<p>2012 年 Google 的工程师 Dmitry Vyukov 在 <a href="http://golang.org/s/go11sched">Scalable Go Scheduler Design Doc</a> 中指出了现有多线程调度器的问题并在多线程调度器上提出了两个改进的手段：</p>
<ol>
<li>在当前的 G-M 模型中引入了处理器 P，增加中间层；</li>
<li>在处理器 P 的基础上实现基于工作窃取的调度器；</li>
</ol>
<p>基于任务窃取的 Go 语言调度器使用了沿用至今的 G-M-P 模型，我们能在 <a href="https://github.com/golang/go/commit/779c45a50700bda0f6ec98429720802e6c1624e8">runtime: improved scheduler</a> 提交中找到任务窃取调度器刚被实现时的<a href="https://github.com/golang/go/blob/779c45a50700bda0f6ec98429720802e6c1624e8/src/pkg/runtime/proc.c">源代码</a>，调度器的 <code>runtime.schedule:779c45a</code> 在这个版本的调度器中反而更简单了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">static</span> <span class="nx">void</span> <span class="nf">schedule</span><span class="p">(</span><span class="nx">void</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">G</span> <span class="o">*</span><span class="nx">gp</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"> <span class="nx">top</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nx">runtime</span><span class="err">·</span><span class="nx">gcwaiting</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="nf">gcstopm</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">        <span class="k">goto</span> <span class="nx">top</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nx">gp</span> <span class="p">=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">m</span><span class="o">-</span><span class="p">&gt;</span><span class="nx">p</span><span class="p">);</span>
</span></span><span class="line"><span class="cl">    <span class="k">if</span><span class="p">(</span><span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">        <span class="nx">gp</span> <span class="p">=</span> <span class="nf">findrunnable</span><span class="p">();</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">    <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">);</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>如果当前运行时在等待垃圾回收，调用 <code>runtime.gcstopm:779c45a</code> 函数；</li>
<li>调用 <code>runtime.runqget:779c45a</code> 和 <code>runtime.findrunnable:779c45a</code> 从本地或者全局的运行队列中获取待执行的 Goroutine；</li>
<li>调用 <code>runtime.execute:779c45a</code> 在当前线程 M 上运行 Goroutine；</li>
</ol>
<p>当前处理器本地的运行队列中不包含 Goroutine 时，调用 <a href="https://draveness.me/golang/tree/runtime.findrunnable:779c45a"><code>runtime.findrunnable:779c45a</code></a> 会触发工作窃取，从其它的处理器的队列中随机获取一些 Goroutine。</p>
<p>运行时 G-M-P 模型中引入的处理器 P 是线程和 Goroutine 的中间层，我们从它的结构体中就能看到处理器与 M 和 G 的关系：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">struct</span> <span class="nx">P</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">Lock</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="kt">uint32</span>	<span class="nx">status</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">P</span><span class="o">*</span>	<span class="nx">link</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">uint32</span>	<span class="nx">tick</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">M</span><span class="o">*</span>	<span class="nx">m</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MCache</span><span class="o">*</span>	<span class="nx">mcache</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">G</span><span class="o">**</span>	<span class="nx">runq</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int32</span>	<span class="nx">runqhead</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int32</span>	<span class="nx">runqtail</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int32</span>	<span class="nx">runqsize</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">G</span><span class="o">*</span>	<span class="nx">gfree</span><span class="p">;</span>
</span></span><span class="line"><span class="cl">	<span class="kt">int32</span>	<span class="nx">gfreecnt</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>处理器持有一个由可运行的 Goroutine 组成的环形的运行队列 <code>runq</code>，还反向持有一个线程。调度器在调度时会从处理器的队列中选择队列头的 Goroutine 放到线程 M 上执行。</p>
<p>基于工作窃取的多线程调度器将每一个线程绑定到了独立的 CPU 上，这些线程会被不同处理器管理，不同的处理器通过工作窃取对任务进行再分配实现任务的平衡，也能提升调度器和 Go 语言程序的整体性能。</p>
<h3 id="抢占式调度">抢占式调度</h3>
<p>对 Go 语言并发模型的修改提升了调度器的性能，但是 1.1 版本中的调度器仍然不支持抢占式调度，程序只能依靠 Goroutine 主动让出 CPU 资源才能触发调度。Go 语言的调度器在 1.2 版本中引入基于协作的抢占式调度解决下面的问题：</p>
<ul>
<li>某些 Goroutine 可以长时间占用线程，造成其它 Goroutine 的饥饿；</li>
<li>垃圾回收需要暂停整个程序（Stop-the-world，STW），最长可能需要几分钟的时间，导致整个程序无法工作；</li>
</ul>
<p>1.2 版本的抢占式调度虽然能够缓解这个问题，但是它实现的抢占式调度是基于协作的，在之后很长的一段时间里 Go 语言的调度器都有一些无法被抢占的边缘情况，例如：for 循环或者垃圾回收长时间占用线程，这些问题中的一部分直到 1.14 才被基于信号的抢占式调度解决。</p>
<h4 id="基于协作的抢占式调度">基于协作的抢占式调度</h4>
<p>可以在 <a href="https://github.com/golang/go/blob/go1.2/src/pkg/runtime/proc.c"><code>pkg/runtime/proc.c</code></a> 文件中找到引入基于协作的抢占式调度后的调度器。Go 语言会在分段栈的机制上实现抢占调度，利用编译器在分段栈上插入的函数，所有 Goroutine 在函数调用时都有机会进入运行时检查是否需要执行抢占。Go 团队通过以下的多个提交实现该特性：</p>
<ul>
<li>runtime: add stackguard0 to G
<ul>
<li>为 Goroutine 引入 <code>stackguard0</code> 字段，该字段被设置成 <code>StackPreempt</code> 意味着当前 Goroutine 发出了抢占请求；</li>
</ul>
</li>
<li>runtime: introduce preemption function (not used for now)
<ul>
<li>引入抢占函数 <a href="https://draveness.me/golang/tree/runtime.preemptone:1e112cd"><code>runtime.preemptone:1e112cd</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.preemptall:1e112cd"><code>runtime.preemptall:1e112cd</code></a>，这两个函数会改变 Goroutine 的 <code>stackguard0</code> 字段发出抢占请求；</li>
<li>定义抢占请求 <code>StackPreempt</code>；</li>
</ul>
</li>
<li>runtime: preempt goroutines for GC
<ul>
<li>在 <a href="https://draveness.me/golang/tree/runtime.stoptheworld:1e112cd"><code>runtime.stoptheworld:1e112cd</code></a> 中调用 <a href="https://draveness.me/golang/tree/runtime.preemptall:1e112cd"><code>runtime.preemptall:1e112cd</code></a> 设置所有处理器上正在运行的 Goroutine 的 <code>stackguard0</code> 为 <code>StackPreempt</code>；</li>
<li>在 <a href="https://draveness.me/golang/tree/runtime.newstack:1e112cd"><code>runtime.newstack:1e112cd</code></a> 中增加抢占的代码，当 <code>stackguard0</code> 等于 <code>StackPreempt</code> 时触发调度器抢占让出线程；</li>
</ul>
</li>
<li>runtime: preempt long-running goroutines
<ul>
<li>在系统监控中，如果一个 Goroutine 的运行时间超过 10ms，就会调用 <a href="https://draveness.me/golang/tree/runtime.retake:1e112cd"><code>runtime.retake:1e112cd</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.preemptone:1e112cd"><code>runtime.preemptone:1e112cd</code></a>；</li>
</ul>
</li>
<li>runtime: more reliable preemption
<ul>
<li>修复 Goroutine 因为周期性执行非阻塞的 CGO 或者系统调用不会被抢占的问题；</li>
</ul>
</li>
</ul>
<p>上面的多个提交实现了抢占式调度，但是还缺少最关键的一个环节 — 编译器如何在函数调用前插入函数，我们能在非常古老的提交 <a href="https://github.com/golang/go/commit/7343e03c433ebb0c302ed97bf832ad3bd3170de6">runtime: stack growth adjustments, cleanup</a> 中找到编译器插入函数的雏形，最新版本的 Go 语言会通过 <a href="https://draveness.me/golang/tree/cmd/internal/obj/x86.stacksplit"><code>cmd/internal/obj/x86.stacksplit</code></a> 插入 <a href="https://draveness.me/golang/tree/runtime.morestack"><code>runtime.morestack</code></a>，该函数可能会调用 <a href="https://draveness.me/golang/tree/runtime.newstack"><code>runtime.newstack</code></a> 触发抢占。从上面的多个提交中，我们能归纳出基于协作的抢占式调度的工作原理：</p>
<ol>
<li>编译器会在调用函数前插入 <a href="https://draveness.me/golang/tree/runtime.morestack"><code>runtime.morestack</code></a>；</li>
<li>Go 语言运行时会在垃圾回收暂停程序、系统监控发现 Goroutine 运行超过 10ms 时发出抢占请求 <code>StackPreempt</code>；</li>
<li>当发生函数调用时，可能会执行编译器插入的 <a href="https://draveness.me/golang/tree/runtime.morestack"><code>runtime.morestack</code></a>，它调用的 <a href="https://draveness.me/golang/tree/runtime.newstack"><code>runtime.newstack</code></a> 会检查 Goroutine 的 <code>stackguard0</code> 字段是否为 <code>StackPreempt</code>；</li>
<li>如果 <code>stackguard0</code> 是 <code>StackPreempt</code>，就会触发抢占让出当前线程；</li>
</ol>
<p>这种实现方式虽然增加了运行时的复杂度，但是实现相对简单，也没有带来过多的额外开销，总体来看还是比较成功的实现，也在 Go 语言中使用了 10 几个版本。因为这里的抢占是通过编译器插入函数实现的，还是需要函数调用作为入口才能触发抢占，所以这是一种<strong>协作式的抢占式调度</strong>。</p>
<h4 id="基于信号的抢占式调度">基于信号的抢占式调度</h4>
<p>基于协作的抢占式调度虽然实现巧妙，但是并不完备，我们能在 <a href="https://github.com/golang/go/issues/24543">runtime: non-cooperative goroutine preemption</a> 中找到一些遗留问题：</p>
<ul>
<li><a href="https://github.com/golang/go/issues/10958">runtime: tight loops should be preemptible #10958</a></li>
<li><a href="https://github.com/golang/go/issues/17174">An empty for{} will block large slice allocation in another goroutine, even with GOMAXPROCS &gt; 1 ? #17174</a></li>
<li><a href="https://github.com/golang/go/issues/15442">runtime: tight loop hangs process completely after some time #15442</a></li>
<li>…</li>
</ul>
<p>Go 语言在 1.14 版本中实现了非协作的抢占式调度，在实现的过程中我们重构已有的逻辑并为 Goroutine 增加新的状态和字段来支持抢占。Go 团队通过下面的一系列提交实现了这一功能，我们可以按时间顺序分析相关提交理解它的工作原理：</p>
<ul>
<li>runtime: add general suspendG/resumeG
<ul>
<li>挂起 Goroutine 的过程是在垃圾回收的栈扫描时完成的，我们通过 <a href="https://draveness.me/golang/tree/runtime.suspendG"><code>runtime.suspendG</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.resumeG"><code>runtime.resumeG</code></a> 两个函数重构栈扫描这一过程；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.suspendG"><code>runtime.suspendG</code></a> 时会将处于运行状态的 Goroutine 的 <code>preemptStop</code> 标记成 <code>true</code>；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.preemptPark"><code>runtime.preemptPark</code></a> 可以挂起当前 Goroutine、将其状态更新成 <code>_Gpreempted</code> 并触发调度器的重新调度，该函数能够交出线程控制权；</li>
</ul>
</li>
<li>runtime: asynchronous preemption function for x86
<ul>
<li>在 x86 架构上增加异步抢占的函数 <a href="https://draveness.me/golang/tree/runtime.asyncPreempt"><code>runtime.asyncPreempt</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.asyncPreempt2"><code>runtime.asyncPreempt2</code></a>；</li>
</ul>
</li>
<li>runtime: use signals to preempt Gs for suspendG
<ul>
<li>支持通过向线程发送信号的方式暂停运行的 Goroutine；</li>
<li>在 <a href="https://draveness.me/golang/tree/runtime.sighandler"><code>runtime.sighandler</code></a> 函数中注册 <code>SIGURG</code> 信号的处理函数 <a href="https://draveness.me/golang/tree/runtime.doSigPreempt"><code>runtime.doSigPreempt</code></a>；</li>
<li>实现 <a href="https://draveness.me/golang/tree/runtime.preemptM"><code>runtime.preemptM</code></a>，它可以通过 <code>SIGURG</code> 信号向线程发送抢占请求；</li>
</ul>
</li>
<li>runtime: implement async scheduler preemption
<ul>
<li>修改 <a href="https://draveness.me/golang/tree/runtime.preemptone"><code>runtime.preemptone</code></a> 函数的实现，加入异步抢占的逻辑；</li>
</ul>
</li>
</ul>
<p>目前的抢占式调度也只会在垃圾回收扫描任务时触发，我们可以梳理一下上述代码实现的抢占式调度过程：</p>
<ol>
<li>程序启动时，在 <a href="https://draveness.me/golang/tree/runtime.sighandler"><code>runtime.sighandler</code></a> 中注册 <code>SIGURG</code> 信号的处理函数 <a href="https://draveness.me/golang/tree/runtime.doSigPreempt"><code>runtime.doSigPreempt</code></a>；</li>
<li>在触发垃圾回收的栈扫描时会调用<code>runtime.suspendG</code>挂起 Goroutine，该函数会执行下面的逻辑：
<ol>
<li>将 <code>_Grunning</code> 状态的 Goroutine 标记成可以被抢占，即将 <code>preemptStop</code> 设置成 <code>true</code>；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.preemptM"><code>runtime.preemptM</code></a> 触发抢占；</li>
</ol>
</li>
<li><a href="https://draveness.me/golang/tree/runtime.preemptM"><code>runtime.preemptM</code></a> 会调用 <a href="https://draveness.me/golang/tree/runtime.signalM"><code>runtime.signalM</code></a> 向线程发送信号 <code>SIGURG</code>；</li>
<li>操作系统会中断正在运行的线程并执行预先注册的信号处理函数 <a href="https://draveness.me/golang/tree/runtime.doSigPreempt"><code>runtime.doSigPreempt</code></a>；</li>
<li><a href="https://draveness.me/golang/tree/runtime.doSigPreempt"><code>runtime.doSigPreempt</code></a> 函数会处理抢占信号，获取当前的 SP 和 PC 寄存器并调用 <a href="https://draveness.me/golang/tree/runtime.sigctxt.pushCall"><code>runtime.sigctxt.pushCall</code></a>；</li>
<li><a href="https://draveness.me/golang/tree/runtime.sigctxt.pushCall"><code>runtime.sigctxt.pushCall</code></a> 会修改寄存器并在程序回到用户态时执行 <a href="https://draveness.me/golang/tree/runtime.asyncPreempt"><code>runtime.asyncPreempt</code></a>；</li>
<li>汇编指令 <a href="https://draveness.me/golang/tree/runtime.asyncPreempt"><code>runtime.asyncPreempt</code></a> 会调用运行时函数 <a href="https://draveness.me/golang/tree/runtime.asyncPreempt2"><code>runtime.asyncPreempt2</code></a>；</li>
<li><a href="https://draveness.me/golang/tree/runtime.asyncPreempt2"><code>runtime.asyncPreempt2</code></a> 会调用 <a href="https://draveness.me/golang/tree/runtime.preemptPark"><code>runtime.preemptPark</code></a>；</li>
<li><a href="https://draveness.me/golang/tree/runtime.preemptPark"><code>runtime.preemptPark</code></a> 会修改当前 Goroutine 的状态到 <code>_Gpreempted</code> 并调用 <a href="https://draveness.me/golang/tree/runtime.schedule"><code>runtime.schedule</code></a> 让当前函数陷入休眠并让出线程，调度器会选择其它的 Goroutine 继续执行；</li>
</ol>
<p>上述 9 个步骤展示了基于信号的抢占式调度的执行过程。除了分析抢占的过程之外，我们还需要讨论一下抢占信号的选择，提案根据以下的四个原因选择 <code>SIGURG</code> 作为触发异步抢占的信号；</p>
<ol>
<li>该信号需要被调试器透传；</li>
<li>该信号不会被内部的 libc 库使用并拦截；</li>
<li>该信号可以随意出现并且不触发任何后果；</li>
<li>我们需要处理多个平台上的不同信号；</li>
</ol>
<p>STW 和栈扫描是一个可以抢占的安全点（Safe-points），所以 Go 语言会在这里先加入抢占功能。基于信号的抢占式调度只解决了垃圾回收和栈扫描时存在的问题，它到目前为止没有解决所有问题，但是这种真抢占式调度是调度器走向完备的开始，相信在未来我们会在更多的地方触发抢占。</p>
<h2 id="调度器启动">调度器启动</h2>
<p>调度器的启动过程是我们平时比较难以接触的过程，不过作为程序启动前的准备工作，理解调度器的启动过程对我们理解调度器的实现原理很有帮助，运行时通过 <a href="https://draveness.me/golang/tree/runtime.schedinit"><code>runtime.schedinit</code></a> 初始化调度器：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">schedinit</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">sched</span><span class="p">.</span><span class="nx">maxmcount</span> <span class="p">=</span> <span class="mi">10000</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sched</span><span class="p">.</span><span class="nx">lastpoll</span> <span class="p">=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nf">nanotime</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="nx">procs</span> <span class="o">:=</span> <span class="nx">ncpu</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">n</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nf">atoi32</span><span class="p">(</span><span class="nf">gogetenv</span><span class="p">(</span><span class="s">&#34;GOMAXPROCS&#34;</span><span class="p">));</span> <span class="nx">ok</span> <span class="o">&amp;&amp;</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">procs</span> <span class="p">=</span> <span class="nx">n</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">procresize</span><span class="p">(</span><span class="nx">procs</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;unknown runnable goroutine during bootstrap&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在调度器初始函数执行的过程中会将 <code>maxmcount</code> 设置成 10000，这也就是一个 Go 语言程序能够创建的最大线程数，虽然最多可以创建 10000 个线程，但是可以同时运行的线程还是由 <code>GOMAXPROCS</code> 变量控制。</p>
<p>我们从环境变量 <code>GOMAXPROCS</code> 获取了程序能够同时运行的最大处理器数之后就会调用 <a href="https://draveness.me/golang/tree/runtime.procresize"><code>runtime.procresize</code></a> 更新程序中处理器的数量，在这时整个程序不会执行任何用户 Goroutine，调度器也会进入锁定状态，<a href="https://draveness.me/golang/tree/runtime.procresize"><code>runtime.procresize</code></a> 的执行过程如下：</p>
<ol>
<li>如果全局变量 <code>allp</code> 切片中的处理器数量少于期望数量，会对切片进行扩容；</li>
<li>使用 <code>new</code> 创建新的处理器结构体并调用 <a href="https://draveness.me/golang/tree/runtime.p.init"><code>runtime.p.init</code></a> 初始化刚刚扩容的处理器；</li>
<li>通过指针将线程 m0 和处理器 <code>allp[0]</code> 绑定到一起；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.p.destroy"><code>runtime.p.destroy</code></a> 释放不再使用的处理器结构；</li>
<li>通过截断改变全局变量 <code>allp</code> 的长度保证与期望处理器数量相等；</li>
<li>将除 <code>allp[0]</code> 之外的处理器 P 全部设置成 <code>_Pidle</code> 并加入到全局的空闲队列中；</li>
</ol>
<p>调用 <a href="https://draveness.me/golang/tree/runtime.procresize"><code>runtime.procresize</code></a> 是调度器启动的最后一步，在这一步过后调度器会完成相应数量处理器的启动，等待用户创建运行新的 Goroutine 并为 Goroutine 调度处理器资源。</p>
<h2 id="创建-goroutine">创建 Goroutine</h2>
<p>想要启动一个新的 Goroutine 来执行任务时，我们需要使用 Go 语言的 <code>go</code> 关键字，编译器会通过 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.stmt"><code>cmd/compile/internal/gc.state.stmt</code></a> 和 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.call"><code>cmd/compile/internal/gc.state.call</code></a> 两个方法将该关键字转换成 <a href="https://draveness.me/golang/tree/runtime.newproc"><code>runtime.newproc</code></a> 函数调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">call</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">k</span> <span class="nx">callKind</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDeferStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callGo</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">call</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1A</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpStaticCall</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TypeMem</span><span class="p">,</span> <span class="nx">newproc</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mem</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.newproc"><code>runtime.newproc</code></a> 的入参是参数大小和表示函数的指针 <code>funcval</code>，它会获取 Goroutine 以及调用方的程序计数器，然后调用 <a href="https://draveness.me/golang/tree/runtime.newproc1"><code>runtime.newproc1</code></a> 函数获取新的 Goroutine 结构体、将其加入处理器的运行队列并在满足条件时调用 <a href="https://draveness.me/golang/tree/runtime.wakep"><code>runtime.wakep</code></a> 唤醒新的处理执行 Goroutine：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">argp</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newg</span> <span class="o">:=</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nx">argp</span><span class="p">,</span> <span class="nx">siz</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">_p_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">().</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">newg</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">mainStarted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">wakep</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.newproc1"><code>runtime.newproc1</code></a> 会根据传入参数初始化一个 <code>g</code> 结构体，我们可以将该函数分成以下几个部分介绍它的实现：</p>
<ol>
<li>获取或者创建新的 Goroutine 结构体；</li>
<li>将传入的参数移到 Goroutine 的栈上；</li>
<li>更新 Goroutine 调度相关的属性；</li>
</ol>
<p>首先是 Goroutine 结构体的创建过程：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newproc1</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">,</span> <span class="nx">argp</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">narg</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">callergp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">callerpc</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">siz</span> <span class="o">:=</span> <span class="nx">narg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">siz</span> <span class="p">=</span> <span class="p">(</span><span class="nx">siz</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">&amp;^</span> <span class="mi">7</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">_p_</span> <span class="o">:=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span> <span class="o">:=</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">newg</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newg</span> <span class="p">=</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">_StackMin</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gidle</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">allgadd</span><span class="p">(</span><span class="nx">newg</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码会先从处理器的 <code>gFree</code> 列表中查找空闲的 Goroutine，如果不存在空闲的 Goroutine，会通过 <a href="https://draveness.me/golang/tree/runtime.malg"><code>runtime.malg</code></a> 创建一个栈大小足够的新结构体。</p>
<p>接下来，我们会调用 <a href="https://draveness.me/golang/tree/runtime.memmove"><code>runtime.memmove</code></a> 将 <code>fn</code> 函数的所有参数拷贝到栈上，<code>argp</code> 和 <code>narg</code> 分别是参数的内存空间和大小，我们在该方法中会将参数对应的内存空间整块拷贝到栈上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">totalSize</span> <span class="o">:=</span> <span class="mi">4</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="o">+</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">MinFrameSize</span>
</span></span><span class="line"><span class="cl">	<span class="nx">totalSize</span> <span class="o">+=</span> <span class="o">-</span><span class="nx">totalSize</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">SpAlign</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">hi</span> <span class="o">-</span> <span class="nx">totalSize</span>
</span></span><span class="line"><span class="cl">	<span class="nx">spArg</span> <span class="o">:=</span> <span class="nx">sp</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">narg</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">spArg</span><span class="p">),</span> <span class="nx">argp</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">narg</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>拷贝了栈上的参数之后，<a href="https://draveness.me/golang/tree/runtime.newproc1"><code>runtime.newproc1</code></a> 会设置新的 Goroutine 结构体的参数，包括栈指针、程序计数器并更新其状态到 <code>_Grunnable</code> 并返回：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">stktopsp</span> <span class="p">=</span> <span class="nx">sp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">gopc</span> <span class="p">=</span> <span class="nx">callerpc</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">startpc</span> <span class="p">=</span> <span class="nx">fn</span><span class="p">.</span><span class="nx">fn</span>
</span></span><span class="line"><span class="cl">	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">newg</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">goid</span> <span class="p">=</span> <span class="nb">int64</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_p_</span><span class="p">.</span><span class="nx">goidcache</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">newg</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="初始化结构体">初始化结构体</h3>
<p><a href="https://draveness.me/golang/tree/runtime.gfget"><code>runtime.gfget</code></a> 通过两种不同的方式获取新的 <a href="https://draveness.me/golang/tree/runtime.g"><code>runtime.g</code></a>：</p>
<ol>
<li>从 Goroutine 所在处理器的 <code>gFree</code> 列表或者调度器的 <code>sched.gFree</code> 列表中获取 <a href="https://draveness.me/golang/tree/runtime.g"><code>runtime.g</code></a>；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.malg"><code>runtime.malg</code></a> 生成一个新的 <a href="https://draveness.me/golang/tree/runtime.g"><code>runtime.g</code></a> 并将结构体追加到全局的 Goroutine 列表 <code>allgs</code> 中。</li>
</ol>
<p><a href="https://draveness.me/golang/tree/runtime.gfget"><code>runtime.gfget</code></a> 中包含两部分逻辑，它会根据处理器中 <code>gFree</code> 列表中 Goroutine 的数量做出不同的决策：</p>
<ol>
<li>当处理器的 Goroutine 列表为空时，会将调度器持有的空闲 Goroutine 转移到当前处理器上，直到 <code>gFree</code> 列表中的 Goroutine 数量达到 32；</li>
<li>当处理器的 Goroutine 数量充足时，会从列表头部返回一个新的 Goroutine；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gfget</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="nx">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="p">(!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">empty</span><span class="p">()</span> <span class="o">||</span> <span class="p">!</span><span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">empty</span><span class="p">())</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">n</span> <span class="p">&lt;</span> <span class="mi">32</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">gp</span> <span class="p">=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nx">noStack</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">				<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">					<span class="k">break</span>
</span></span><span class="line"><span class="cl">				<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">push</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">goto</span> <span class="nx">retry</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">gFree</span><span class="p">.</span><span class="nf">pop</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当调度器的 <code>gFree</code> 和处理器的 <code>gFree</code> 列表都不存在结构体时，运行时会调用 <a href="https://draveness.me/golang/tree/runtime.malg"><code>runtime.malg</code></a> 初始化新的 <a href="https://draveness.me/golang/tree/runtime.g"><code>runtime.g</code></a> 结构，如果申请的堆栈大小大于 0，这里会通过 <a href="https://draveness.me/golang/tree/runtime.stackalloc"><code>runtime.stackalloc</code></a> 分配 2KB 的栈空间：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">malg</span><span class="p">(</span><span class="nx">stacksize</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">g</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">g</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">stacksize</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">stacksize</span> <span class="p">=</span> <span class="nf">round2</span><span class="p">(</span><span class="nx">_StackSystem</span> <span class="o">+</span> <span class="nx">stacksize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span> <span class="p">=</span> <span class="nf">stackalloc</span><span class="p">(</span><span class="nb">uint32</span><span class="p">(</span><span class="nx">stacksize</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">newg</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
</span></span><span class="line"><span class="cl">		<span class="nx">newg</span><span class="p">.</span><span class="nx">stackguard1</span> <span class="p">=</span> <span class="p">^</span><span class="nb">uintptr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">newg</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.malg"><code>runtime.malg</code></a> 返回的 Goroutine 会存储到全局变量 <code>allgs</code> 中。</p>
<p>简单总结一下，<a href="https://draveness.me/golang/tree/runtime.newproc1"><code>runtime.newproc1</code></a> 会从处理器或者调度器的缓存中获取新的结构体，也可以调用 <a href="https://draveness.me/golang/tree/runtime.malg"><code>runtime.malg</code></a> 函数创建。</p>
<h3 id="运行队列">运行队列</h3>
<p><a href="https://draveness.me/golang/tree/runtime.runqput"><code>runtime.runqput</code></a> 会将 Goroutine 放到运行队列上，这既可能是全局的运行队列，也可能是处理器本地的运行队列：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">runqput</span><span class="p">(</span><span class="nx">_p_</span> <span class="o">*</span><span class="nx">p</span><span class="p">,</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">next</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">retryNext</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">oldnext</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="p">!</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runnext</span><span class="p">.</span><span class="nf">cas</span><span class="p">(</span><span class="nx">oldnext</span><span class="p">,</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">goto</span> <span class="nx">retryNext</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">oldnext</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">return</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span> <span class="p">=</span> <span class="nx">oldnext</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">retry</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="nx">h</span> <span class="o">:=</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">LoadAcq</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqhead</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">t</span> <span class="o">:=</span> <span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">t</span><span class="o">-</span><span class="nx">h</span> <span class="p">&lt;</span> <span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">[</span><span class="nx">t</span><span class="o">%</span><span class="nb">uint32</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runq</span><span class="p">))].</span><span class="nf">set</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">atomic</span><span class="p">.</span><span class="nf">StoreRel</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">_p_</span><span class="p">.</span><span class="nx">runqtail</span><span class="p">,</span> <span class="nx">t</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">runqputslow</span><span class="p">(</span><span class="nx">_p_</span><span class="p">,</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">t</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">goto</span> <span class="nx">retry</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li>当 <code>next</code> 为 <code>true</code> 时，将 Goroutine 设置到处理器的 <code>runnext</code> 作为下一个处理器执行的任务；</li>
<li>当 <code>next</code> 为 <code>false</code> 并且本地运行队列还有剩余空间时，将 Goroutine 加入处理器持有的本地运行队列；</li>
<li>当处理器的本地运行队列已经没有剩余空间时就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 通过 <a href="https://draveness.me/golang/tree/runtime.runqputslow"><code>runtime.runqputslow</code></a> 添加到调度器持有的全局运行队列上；</li>
</ol>
<p>处理器本地的运行队列是一个使用数组构成的环形链表，它最多可以存储 256 个待执行任务。</p>
<blockquote>
<p>Go 语言有两个运行队列，其中一个是处理器本地的运行队列，另一个是调度器持有的全局运行队列，只有在本地运行队列没有剩余空间时才会使用全局队列。</p>
</blockquote>
<h3 id="调度信息">调度信息</h3>
<p>运行时创建 Goroutine 时会通过下面的代码设置调度相关的信息，前两行代码会分别将程序计数器和 Goroutine 设置成 <a href="https://draveness.me/golang/tree/runtime.goexit"><code>runtime.goexit</code></a> 和新创建 Goroutine 运行的函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">funcPC</span><span class="p">(</span><span class="nx">goexit</span><span class="p">)</span> <span class="o">+</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PCQuantum</span>
</span></span><span class="line"><span class="cl">	<span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">.</span><span class="nx">g</span> <span class="p">=</span> <span class="nf">guintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">newg</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gostartcallfn</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">newg</span><span class="p">.</span><span class="nx">sched</span><span class="p">,</span> <span class="nx">fn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述调度信息 <code>sched</code> 不是初始化后的 Goroutine 的最终结果，它还需要经过 <a href="https://draveness.me/golang/tree/runtime.gostartcallfn"><code>runtime.gostartcallfn</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.gostartcall"><code>runtime.gostartcall</code></a> 的处理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gostartcallfn</span><span class="p">(</span><span class="nx">gobuf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fv</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gostartcall</span><span class="p">(</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">.</span><span class="nx">fn</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">fv</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gostartcall</span><span class="p">(</span><span class="nx">buf</span> <span class="o">*</span><span class="nx">gobuf</span><span class="p">,</span> <span class="nx">fn</span><span class="p">,</span> <span class="nx">ctxt</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">RegSize</span> <span class="p">&gt;</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span> <span class="o">-=</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">sp</span><span class="p">))</span> <span class="p">=</span> <span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">buf</span><span class="p">.</span><span class="nx">ctxt</span> <span class="p">=</span> <span class="nx">ctxt</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>调度信息的 <code>sp</code> 中存储了 <a href="https://draveness.me/golang/tree/runtime.goexit"><code>runtime.goexit</code></a> 函数的程序计数器，而 <code>pc</code> 中存储了传入函数的程序计数器。因为 <code>pc</code> 寄存器的作用就是存储程序接下来运行的位置，所以 <code>pc</code> 的使用比较好理解，但是 <code>sp</code> 中存储的 <a href="https://draveness.me/golang/tree/runtime.goexit"><code>runtime.goexit</code></a> 会让人感到困惑，我们需要配合下面的调度循环来理解它的作用。</p>
<h2 id="循环调度">循环调度</h2>
<p>调度器启动之后，Go 语言运行时会调用 <a href="https://draveness.me/golang/tree/runtime.mstart"><code>runtime.mstart</code></a> 以及 <a href="https://draveness.me/golang/tree/runtime.mstart1"><code>runtime.mstart1</code></a>，前者会初始化 g0 的 <code>stackguard0</code> 和 <code>stackguard1</code> 字段，后者会初始化线程并调用 <a href="https://draveness.me/golang/tree/runtime.schedule"><code>runtime.schedule</code></a> 进入调度循环：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">schedule</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">top</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">inheritTime</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">%</span><span class="mi">61</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">runqsize</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">gp</span> <span class="p">=</span> <span class="nf">globrunqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">runqget</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">gp</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="p">=</span> <span class="nf">findrunnable</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">inheritTime</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.schedule"><code>runtime.schedule</code></a> 函数会从下面几个地方查找待执行的 Goroutine：</p>
<ol>
<li>为了保证公平，当全局运行队列中有待执行的 Goroutine 时，通过 <code>schedtick</code> 保证有一定几率会从全局的运行队列中查找对应的 Goroutine；</li>
<li>从处理器本地的运行队列中查找待执行的 Goroutine；</li>
<li>如果前两种方法都没有找到 Goroutine，会通过 <a href="https://draveness.me/golang/tree/runtime.findrunnable"><code>runtime.findrunnable</code></a> 进行阻塞地查找 Goroutine；</li>
</ol>
<p><a href="https://draveness.me/golang/tree/runtime.findrunnable"><code>runtime.findrunnable</code></a> 的实现非常复杂，这个 300 多行的函数通过以下的过程获取可运行的 Goroutine：</p>
<ol>
<li>从本地运行队列、全局运行队列中查找；</li>
<li>从网络轮询器中查找是否有 Goroutine 等待运行；</li>
<li>通过 <a href="https://draveness.me/golang/tree/runtime.runqsteal"><code>runtime.runqsteal</code></a> 尝试从其他随机的处理器中窃取待运行的 Goroutine，该函数还可能窃取处理器的计时器；</li>
</ol>
<p>因为函数的实现过于复杂，上述的执行过程是经过简化的，总而言之，当前函数一定会返回一个可执行的 Goroutine，如果当前不存在就会阻塞等待。</p>
<p>接下来由 <a href="https://draveness.me/golang/tree/runtime.execute"><code>runtime.execute</code></a> 执行获取的 Goroutine，做好准备工作后，它会通过 <a href="https://draveness.me/golang/tree/runtime.gogo"><code>runtime.gogo</code></a> 将 Goroutine 调度到当前线程上。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">execute</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">inheritTime</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">curg</span> <span class="p">=</span> <span class="nx">gp</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span>
</span></span><span class="line"><span class="cl">	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitsince</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">preempt</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">stackguard0</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">stack</span><span class="p">.</span><span class="nx">lo</span> <span class="o">+</span> <span class="nx">_StackGuard</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="p">!</span><span class="nx">inheritTime</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">().</span><span class="nx">schedtick</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">gogo</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">sched</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.gogo"><code>runtime.gogo</code></a> 在不同处理器架构上的实现都不同，但是也都大同小异，下面是该函数在 386 架构上的实现：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">TEXT</span> <span class="nx">runtime</span><span class="err">·</span><span class="nf">gogo</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span> <span class="nx">NOSPLIT</span><span class="p">,</span> <span class="err">$</span><span class="mi">8</span><span class="o">-</span><span class="mi">4</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="nx">buf</span><span class="o">+</span><span class="mi">0</span><span class="p">(</span><span class="nx">FP</span><span class="p">),</span> <span class="nx">BX</span>     <span class="c1">// 获取调度信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nf">gobuf_g</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="mi">0</span><span class="p">(</span><span class="nx">DX</span><span class="p">),</span> <span class="nx">CX</span>         <span class="c1">// 保证 Goroutine 不为空
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nf">get_tls</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="nx">DX</span><span class="p">,</span> <span class="nf">g</span><span class="p">(</span><span class="nx">CX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">SP</span>  <span class="c1">// 将 runtime.goexit 函数的 PC 恢复到 SP 中
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">MOVL</span> <span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">AX</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">DX</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_sp</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ret</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="err">$</span><span class="mi">0</span><span class="p">,</span> <span class="nf">gobuf_ctxt</span><span class="p">(</span><span class="nx">BX</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">MOVL</span> <span class="nf">gobuf_pc</span><span class="p">(</span><span class="nx">BX</span><span class="p">),</span> <span class="nx">BX</span>  <span class="c1">// 获取待执行函数的程序计数器
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">JMP</span>  <span class="nx">BX</span>                <span class="c1">// 开始执行
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>它从 <a href="https://draveness.me/golang/tree/runtime.gobuf"><code>runtime.gobuf</code></a> 中取出了 <a href="https://draveness.me/golang/tree/runtime.goexit"><code>runtime.goexit</code></a> 的程序计数器和待执行函数的程序计数器，其中：</p>
<ul>
<li><a href="https://draveness.me/golang/tree/runtime.goexit"><code>runtime.goexit</code></a> 的程序计数器被放到了栈 SP 上；</li>
<li>待执行函数的程序计数器被放到了寄存器 BX 上；</li>
</ul>
<p>在函数调用一节中，我们曾经介绍过 Go 语言的调用惯例，正常的函数调用都会使用 <code>CALL</code> 指令，该指令会将调用方的返回地址加入栈寄存器 SP 中，然后跳转到目标函数；当目标函数返回后，会从栈中查找调用的地址并跳转回调用方继续执行剩下的代码。</p>
<p>经过一系列复杂的函数调用，我们最终在当前线程的 g0 的栈上调用 <a href="https://draveness.me/golang/tree/runtime.goexit0"><code>runtime.goexit0</code></a> 函数，该函数会将 Goroutine 转换会 <code>_Gdead</code> 状态、清理其中的字段、移除 Goroutine 和线程的关联并调用 <a href="https://draveness.me/golang/tree/runtime.gfput"><code>runtime.gfput</code></a> 重新加入处理器的 Goroutine 空闲列表 <code>gFree</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goexit0</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gdead</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">m</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">param</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">labels</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">timer</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">dropg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">gfput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">schedule</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在最后 <a href="https://draveness.me/golang/tree/runtime.goexit0"><code>runtime.goexit0</code></a> 会重新调用 <a href="https://draveness.me/golang/tree/runtime.schedule"><code>runtime.schedule</code></a> 触发新一轮的 Goroutine 调度，Go 语言中的运行时调度循环会从 <a href="https://draveness.me/golang/tree/runtime.schedule"><code>runtime.schedule</code></a> 开始，最终又回到 <a href="https://draveness.me/golang/tree/runtime.schedule"><code>runtime.schedule</code></a>，我们可以认为调度循环永远都不会返回。</p>
<h2 id="触发调度">触发调度</h2>
<ul>
<li>主动挂起 — <a href="https://draveness.me/golang/tree/runtime.gopark"><code>runtime.gopark</code></a> -&gt; <a href="https://draveness.me/golang/tree/runtime.park_m"><code>runtime.park_m</code></a></li>
<li>系统调用 — <a href="https://draveness.me/golang/tree/runtime.exitsyscall"><code>runtime.exitsyscall</code></a> -&gt; <a href="https://draveness.me/golang/tree/runtime.exitsyscall0"><code>runtime.exitsyscall0</code></a></li>
<li>协作式调度 — <a href="https://draveness.me/golang/tree/runtime.Gosched"><code>runtime.Gosched</code></a> -&gt; <a href="https://draveness.me/golang/tree/runtime.gosched_m"><code>runtime.gosched_m</code></a> -&gt; <a href="https://draveness.me/golang/tree/runtime.goschedImpl"><code>runtime.goschedImpl</code></a></li>
<li>系统监控 — <a href="https://draveness.me/golang/tree/runtime.sysmon"><code>runtime.sysmon</code></a> -&gt; <a href="https://draveness.me/golang/tree/runtime.retake"><code>runtime.retake</code></a> -&gt; <a href="https://draveness.me/golang/tree/runtime.preemptone"><code>runtime.preemptone</code></a></li>
</ul>
<h3 id="主动挂起">主动挂起</h3>
<p><a href="https://draveness.me/golang/tree/runtime.gopark"><code>runtime.gopark</code></a> 是触发调度最常见的方法，该函数会将当前 Goroutine 暂停，被暂停的任务不会放回运行队列，我们来分析该函数的实现原理：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gopark</span><span class="p">(</span><span class="nx">unlockf</span> <span class="kd">func</span><span class="p">(</span><span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">lock</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">reason</span> <span class="nx">waitReason</span><span class="p">,</span> <span class="nx">traceEv</span> <span class="kt">byte</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mp</span> <span class="o">:=</span> <span class="nf">acquirem</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nx">mp</span><span class="p">.</span><span class="nx">curg</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mp</span><span class="p">.</span><span class="nx">waitlock</span> <span class="p">=</span> <span class="nx">lock</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mp</span><span class="p">.</span><span class="nx">waitunlockf</span> <span class="p">=</span> <span class="nx">unlockf</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">waitreason</span> <span class="p">=</span> <span class="nx">reason</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceev</span> <span class="p">=</span> <span class="nx">traceEv</span>
</span></span><span class="line"><span class="cl">	<span class="nx">mp</span><span class="p">.</span><span class="nx">waittraceskip</span> <span class="p">=</span> <span class="nx">traceskip</span>
</span></span><span class="line"><span class="cl">	<span class="nf">releasem</span><span class="p">(</span><span class="nx">mp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mcall</span><span class="p">(</span><span class="nx">park_m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述会通过 <a href="https://draveness.me/golang/tree/runtime.mcall"><code>runtime.mcall</code></a> 切换到 g0 的栈上调用 <a href="https://draveness.me/golang/tree/runtime.park_m"><code>runtime.park_m</code></a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">park_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">dropg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">schedule</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.park_m"><code>runtime.park_m</code></a> 会将当前 Goroutine 的状态从 <code>_Grunning</code> 切换至 <code>_Gwaiting</code>，调用 <a href="https://draveness.me/golang/tree/runtime.dropg"><code>runtime.dropg</code></a> 移除线程和 Goroutine 之间的关联，在这之后就可以调用 <a href="https://draveness.me/golang/tree/runtime.schedule"><code>runtime.schedule</code></a> 触发新一轮的调度了。</p>
<p>当 Goroutine 等待的特定条件满足后，运行时会调用 <a href="https://draveness.me/golang/tree/runtime.goready"><code>runtime.goready</code></a> 将因为调用 <a href="https://draveness.me/golang/tree/runtime.gopark"><code>runtime.gopark</code></a> 而陷入休眠的 Goroutine 唤醒。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">systemstack</span><span class="p">(</span><span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">traceskip</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">})</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">ready</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">traceskip</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">next</span> <span class="kt">bool</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">_g_</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Gwaiting</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">runqput</span><span class="p">(</span><span class="nx">_g_</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">(),</span> <span class="nx">gp</span><span class="p">,</span> <span class="nx">next</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">npidle</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">atomic</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">nmspinning</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">wakep</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.ready"><code>runtime.ready</code></a> 会将准备就绪的 Goroutine 的状态切换至 <code>_Grunnable</code> 并将其加入处理器的运行队列中，等待调度器的调度。</p>
<h3 id="系统调用">系统调用</h3>
<p>系统调用也会触发运行时调度器的调度，为了处理特殊的系统调用，我们甚至在 Goroutine 中加入了 <code>_Gsyscall</code> 状态，Go 语言通过 <a href="https://draveness.me/golang/tree/syscall.Syscall"><code>syscall.Syscall</code></a> 和 <a href="https://draveness.me/golang/tree/syscall.RawSyscall"><code>syscall.RawSyscall</code></a> 等使用汇编语言编写的方法封装操作系统提供的所有系统调用，其中 <a href="https://draveness.me/golang/tree/syscall.Syscall"><code>syscall.Syscall</code></a> 的实现如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="err">#</span><span class="nx">define</span> <span class="nx">INVOKE_SYSCALL</span>	<span class="nx">INT</span>	<span class="err">$</span><span class="mh">0x80</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="nx">TEXT</span> <span class="err">·</span><span class="nf">Syscall</span><span class="p">(</span><span class="nx">SB</span><span class="p">),</span><span class="nx">NOSPLIT</span><span class="p">,</span><span class="err">$</span><span class="mi">0</span><span class="o">-</span><span class="mi">28</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">entersyscall</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">INVOKE_SYSCALL</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">exitsyscall</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">RET</span>
</span></span><span class="line"><span class="cl"><span class="nx">ok</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">CALL</span>	<span class="nx">runtime</span><span class="err">·</span><span class="nf">exitsyscall</span><span class="p">(</span><span class="nx">SB</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">RET</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在通过汇编指令 <code>INVOKE_SYSCALL</code> 执行系统调用前后，上述函数会调用运行时的 <a href="https://draveness.me/golang/tree/runtime.entersyscall"><code>runtime.entersyscall</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.exitsyscall"><code>runtime.exitsyscall</code></a>，正是这一层包装能够让我们在陷入系统调用前触发运行时的准备和清理工作。</p>
<h3 id="协作式调度">协作式调度</h3>
<p>协作式调度<a href="https://draveness.me/golang/tree/runtime.Gosched"><code>runtime.Gosched</code></a> 函数会主动让出处理器，允许其他 Goroutine 运行。该函数无法挂起 Goroutine，调度器可能会将当前 Goroutine 调度到其他线程上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">Gosched</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">checkTimeouts</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">mcall</span><span class="p">(</span><span class="nx">gosched_m</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gosched_m</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">goschedImpl</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">casgstatus</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">_Grunning</span><span class="p">,</span> <span class="nx">_Grunnable</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">dropg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nf">lock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">globrunqput</span><span class="p">(</span><span class="nx">gp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">sched</span><span class="p">.</span><span class="nx">lock</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">schedule</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>经过连续几次跳转，我们最终在 g0 的栈上调用 <a href="https://draveness.me/golang/tree/runtime.goschedImpl"><code>runtime.goschedImpl</code></a>，运行时会更新 Goroutine 的状态到 <code>_Grunnable</code>，让出当前的处理器并将 Goroutine 重新放回全局队列，在最后，该函数会调用 <a href="https://draveness.me/golang/tree/runtime.schedule"><code>runtime.schedule</code></a> 触发调度。</p>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">hlday</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2022-03-09
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/design-pattern/singleton/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">设计模式-单例模式</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/mysql/mysql%E5%B8%B8%E8%A7%81%E5%8F%98%E9%87%8F/">
            <span class="next-text nav-default">MySQL常见变量</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="hTangle/hxsup-blog-image"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <style>
      utterances {
        max-width: 75%;
        width: 1200px;
      }
    </style>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <link href="https://cdn.staticfile.org/bootstrap/5.0.2/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdn.staticfile.org/bootstrap/5.0.2/js/bootstrap.min.js" crossorigin="anonymous"></script>
<style>
  .modal {
    display: none;
     
    position: fixed;
     
    z-index: 1000;
     
    padding-top: 100px;
     
    left: 0;
    top: 0;
    width: 100%;
     
    height: 100%;
     
    overflow: auto;
     
    background-color: #FFFFFF;
     
    background-color: rgba(255, 255,255, 0.98);
     
  }

   
  .modal-content {
    margin: auto;
    display: block;
  }

   
  .modal-content,
  #caption {
    animation-name: zoom;
    animation-duration: 0.6s;
  }

  @keyframes zoom {
    from {
      transform: scale(0)
    }

    to {
      transform: scale(1)
    }
  }
  .image-show-center {
    display: block !important;
    margin: 0 auto;
    border: 0;
    border-radius: 5px;
     
  }
</style>
<div id="myModal" class="modal" onclick="disShowImage()">
  <img class="modal-content" id="img01" onmousewheel="return zoomImg(this)"
       style="width: auto;height: auto;max-width: 100%;max-height: 100%;">
</div>
<script type="text/javascript">
  var modal = document.getElementById("myModal");
  var modalImg = document.getElementById("img01");
  
  function disShowImage() {
    modal.style.display = "none";
  }
  function zoomImg(obj) {
    
    let zoom = parseInt(obj.style.zoom, 10) || 100;
    
    zoom += event.wheelDelta / 12;
    if (zoom > 0) {
      obj.style.zoom = zoom + '%';
    }
    return false;
  }
  $(function () {
    console.log("init")
    var imgs=$("img");
    for(var i=0;i<imgs.length;i++){
      imgs[i].className="image-show-center rounded";
    }
    
    $("img").on('click', function () {
      console.log("test---", $(this).attr("src"))
      modal.style.display = "block";
      modalImg.style.zoom = "reset";
      modalImg.src = $(this).attr("src");
      imageClicked = true;
    })
    
  })
</script>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="hsup1994@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hTangle" class="iconfont icon-github" title="github"></a>
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2022 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span><a href="/">hlday</a></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.bfb94e1fe4773651a6fe907d388ed08d7d6f9628a062d0740d992e1dfb49466e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
