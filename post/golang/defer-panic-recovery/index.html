<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Defer Panic Recovery - HLDay</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="hlday" /><meta name="description" content="Golang defer/panic/recovery功能的原理分析" /><meta name="keywords" content="hlday, blog, go, python, linux, shell" />





<script async src="https://www.googletagmanager.com/gtag/js?id=G-59Y2CYW544"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-59Y2CYW544');
</script>

<meta name="generator" content="Hugo 0.93.2 with theme even" />


<link rel="canonical" href="/post/golang/defer-panic-recovery/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">

<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

<link href="/sass/main.min.b5a744db6de49a86cadafb3b70f555ab443f83c307a483402259e94726b045ff.css" rel="stylesheet">



<meta property="og:title" content="Defer Panic Recovery" />
<meta property="og:description" content="Golang defer/panic/recovery功能的原理分析" />
<meta property="og:type" content="article" />
<meta property="og:url" content="/post/golang/defer-panic-recovery/" /><meta property="article:section" content="post" />
<meta property="article:published_time" content="2022-06-24T14:53:41+08:00" />
<meta property="article:modified_time" content="2022-06-24T14:53:41+08:00" />

<meta itemprop="name" content="Defer Panic Recovery">
<meta itemprop="description" content="Golang defer/panic/recovery功能的原理分析"><meta itemprop="datePublished" content="2022-06-24T14:53:41+08:00" />
<meta itemprop="dateModified" content="2022-06-24T14:53:41+08:00" />
<meta itemprop="wordCount" content="7286">
<meta itemprop="keywords" content="go," /><meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Defer Panic Recovery"/>
<meta name="twitter:description" content="Golang defer/panic/recovery功能的原理分析"/>

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">HLDay</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="/image/bing">
        <li class="mobile-menu-item">BingDailyPicture</li>
      </a><a href="/post/preview/">
        <li class="mobile-menu-item">Share</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel" style="max-width: 75%; width: 70% !important;">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">HLDay</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/image/bing">BingDailyPicture</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/preview/">Share</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Defer Panic Recovery</h1>

      <div class="post-meta">
        <span class="post-time"> 2022-06-24 </span>
        <div class="post-category">
            <a href="/categories/go/"> go </a>
            </div>
          <span class="more-meta"> 7286 words </span>
          <span class="more-meta"> 15 mins read </span>
        <span id="busuanzi_container_page_pv" class="more-meta"> <span id="busuanzi_value_page_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> times read </span>
      </div>
    </header>

    <div class="post-toc" id="post-toc" style="position: fixed !important;width:14%;top:10%;right: 1% !important;">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#defer">defer</a>
          <ul>
            <li><a href="#defer函数执行顺序">defer函数执行顺序</a></li>
            <li><a href="#defer数据结构">defer数据结构</a></li>
            <li><a href="#执行">执行</a></li>
            <li><a href="#堆上分配">堆上分配</a></li>
            <li><a href="#栈上分配">栈上分配</a></li>
            <li><a href="#开放编码">开放编码</a></li>
            <li><a href="#总结">总结</a></li>
          </ul>
        </li>
        <li><a href="#paincrecovery">painc&amp;&amp;recovery</a>
          <ul>
            <li><a href="#现象">现象</a></li>
            <li><a href="#panic数据结构">panic数据结构</a></li>
            <li><a href="#程序崩溃">程序崩溃</a></li>
            <li><a href="#崩溃恢复">崩溃恢复</a></li>
            <li><a href="#总结-1">总结</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <h2 id="defer">defer</h2>
<p>Go 语言的 <code>defer</code> 会在当前函数返回前执行传入的函数，它会经常被用于关闭文件描述符、关闭数据库连接以及解锁资源。</p>
<p>常用的一种方式为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">createPost</span><span class="p">(</span><span class="nx">db</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">DB</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">tx</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="k">defer</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Post</span><span class="p">{</span><span class="nx">Author</span><span class="p">:</span> <span class="s">&#34;&#34;</span><span class="p">}).</span><span class="nx">Error</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">        <span class="k">return</span> <span class="nx">err</span>
</span></span><span class="line"><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="cl">    
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">().</span><span class="nx">Error</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果tx.Commit()执行失败，则函数退出时会默认执行tx.Rollback()，但是如果执行成功，也会执行tx.Rollback()，但是不会影响已经提交的事务。</p>
<p>需要思考两个问题：</p>
<ul>
<li>多个defer函数的调用顺序：
<ul>
<li>后调用的 <code>defer</code> 函数会被追加到 Goroutine <code>_defer</code> 链表的最前面；</li>
<li>运行 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 时是从前到后依次执行；</li>
</ul>
</li>
<li><code>defer</code> 关键字使用传值的方式传递参数时会进行预计算，导致不符合预期的结果：调用 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 函数创建新的延迟调用时就会立刻拷贝函数的参数，函数的参数不会等到真正执行时计算；</li>
</ul>
<h3 id="defer函数执行顺序">defer函数执行顺序</h3>
<p>假设多次调用defer</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其输出为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">4
</span></span><span class="line"><span class="cl">3
</span></span><span class="line"><span class="cl">2
</span></span><span class="line"><span class="cl">1
</span></span><span class="line"><span class="cl">0
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以defer的调用顺序为先进后出的方式（类似于堆栈，<code>实际上是链表，后加入的会插入到链表的首部</code>），defer函数只会在当前函数退出前被调用。</p>
<p>在看下一段代码的输出</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">testDeferValue</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">startedAt</span> <span class="o">:=</span> <span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Since</span><span class="p">(</span><span class="nx">startedAt</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nf">testDeferValue</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其输出为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">151ns
</span></span></code></pre></td></tr></table>
</div>
</div><p>而我们预期的输出是1s，问题出在哪？</p>
<p>Go 语言中所有的函数调用都是传值的，虽然 <code>defer</code> 是关键字，但是也继承了这个特性。调用 <code>defer</code> 关键字会立刻拷贝函数中引用的外部参数，所以 <code>time.Since(startedAt)</code> 的结果不是在 <code>main</code> 函数退出之前计算的，而是在 <code>defer</code> 关键字调用时计算的，最终导致上述代码输出 0s。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">test</span><span class="p">()</span> <span class="p">(</span><span class="nx">a</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="p">=</span> <span class="mi">5</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nb">println</span><span class="p">(</span><span class="s">&#34;direct&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nb">println</span><span class="p">(</span><span class="s">&#34;func&#34;</span><span class="p">,</span> <span class="nx">a</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">a</span> <span class="p">=</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">a</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面这个函数的输出为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="mi">10</span>
</span></span><span class="line"><span class="cl"><span class="nx">direct</span> <span class="mi">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>虽然调用 <code>defer</code> 关键字时也使用值传递，但是因为拷贝的是函数指针，所以使用匿名函数能解决上述问题。</p>
<h3 id="defer数据结构">defer数据结构</h3>
<p>defer的数据结构如下</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">_defer</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">siz</span>     <span class="kt">int32</span> <span class="c1">// includes both arguments and results
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">started</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">heap</span>    <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="c1">// openDefer indicates that this _defer is for a frame with open-coded
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// defers. We have only one defer record for the entire frame (which may
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// currently have 0, 1, or more defers active).
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">openDefer</span> <span class="kt">bool</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span>        <span class="kt">uintptr</span>  <span class="c1">// sp at time of defer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pc</span>        <span class="kt">uintptr</span>  <span class="c1">// pc at time of defer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fn</span>        <span class="o">*</span><span class="nx">funcval</span> <span class="c1">// can be nil for open-coded defers
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">_panic</span>    <span class="o">*</span><span class="nx">_panic</span>  <span class="c1">// panic that is running defer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">link</span>      <span class="o">*</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="c1">// If openDefer is true, the fields below record values about the stack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// frame and associated function that has the open-coded defer(s). sp
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// above will be the sp for the frame, and pc will be address of the
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// deferreturn call in the function.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">fd</span>   <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// funcdata for the function associated with the frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">varp</span> <span class="kt">uintptr</span>        <span class="c1">// value of varp for the stack frame
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// framepc is the current pc associated with the stack frame. Together,
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// with sp above (which is the sp associated with the stack frame),
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// framepc/sp can be used as pc/sp pair to continue a stack trace via
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="c1">// gentraceback().
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">framepc</span> <span class="kt">uintptr</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>defer是一个链表，通过link将defer连接到一起。</p>
<ul>
<li><code>siz</code> 是参数和结果的内存大小；</li>
<li><code>sp</code> 和 <code>pc</code> 分别代表栈指针和调用方的程序计数器；</li>
<li><code>fn</code> 是 <code>defer</code> 关键字中传入的函数；</li>
<li><code>_panic</code> 是触发延迟调用的结构体，可能为空；</li>
<li><code>openDefer</code> 表示当前 <code>defer</code> 是否经过开放编码的优化；</li>
</ul>
<h3 id="执行">执行</h3>
<p><a href="https://github.com/golang/go/blob/41d8e61a6b9d8f9db912626eb2bbc535e929fefc/src/cmd/compile/internal/gc/ssa.go#L1114">中间代码生成阶段</a>会负责处理程序中的defer</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="k">case</span> <span class="nx">ODEFER</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">Debug_defer</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="kd">var</span> <span class="nx">defertype</span> <span class="kt">string</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">defertype</span> <span class="p">=</span> <span class="s">&#34;open-coded&#34;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">==</span> <span class="nx">EscNever</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">defertype</span> <span class="p">=</span> <span class="s">&#34;stack-allocated&#34;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">defertype</span> <span class="p">=</span> <span class="s">&#34;heap-allocated&#34;</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nf">Warnl</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Pos</span><span class="p">,</span> <span class="s">&#34;%s defer&#34;</span><span class="p">,</span> <span class="nx">defertype</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nf">openDeferRecord</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">)</span> <span class="c1">// 开放编码
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">d</span> <span class="o">:=</span> <span class="nx">callDefer</span> <span class="c1">// 堆分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">==</span> <span class="nx">EscNever</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">d</span> <span class="p">=</span> <span class="nx">callDeferStack</span> <span class="c1">// 栈分配
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">s</span><span class="p">.</span><span class="nf">callResult</span><span class="p">(</span><span class="nx">n</span><span class="p">.</span><span class="nx">Left</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="堆上分配">堆上分配</h3>
<p>根据 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.stmt"><code>cmd/compile/internal/gc.state.stmt</code></a> 方法对 <code>defer</code> 的处理我们可以看出，堆上分配的 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体是默认的兜底方案，当该方案被启用时，编译器会调用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.callResult"><code>cmd/compile/internal/gc.state.callResult</code></a> 和 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.call"><code>cmd/compile/internal/gc.state.call</code></a>，这表示 <code>defer</code> 在编译器看来也是函数调用。</p>
<p><a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.call"><code>cmd/compile/internal/gc.state.call</code></a> 会负责为所有函数和方法调用生成中间代码，它的工作包括以下内容：</p>
<ol>
<li>获取需要执行的函数名、闭包指针、代码指针和函数调用的接收方；</li>
<li>获取栈地址并将函数或者方法的参数写入栈中；</li>
<li>使用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.newValue1A"><code>cmd/compile/internal/gc.state.newValue1A</code></a> 以及相关函数生成函数调用的中间代码；</li>
<li>如果当前调用的函数是 <code>defer</code>，那么会单独生成相关的结束代码块；</li>
<li>获取函数的返回值地址并结束当前调用；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">call</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">k</span> <span class="nx">callKind</span><span class="p">,</span> <span class="nx">returnResultAddr</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">call</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDeferStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 在栈上初始化 defer 结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">		<span class="k">switch</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">case</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDefer</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">			<span class="nx">aux</span> <span class="o">:=</span> <span class="nx">ssa</span><span class="p">.</span><span class="nf">StaticAuxCall</span><span class="p">(</span><span class="nx">deferproc</span><span class="p">,</span> <span class="nx">ACArgs</span><span class="p">,</span> <span class="nx">ACResults</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">call</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1A</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpStaticCall</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TypeMem</span><span class="p">,</span> <span class="nx">aux</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mem</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">call</span><span class="p">.</span><span class="nx">AuxInt</span> <span class="p">=</span> <span class="nx">stksize</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">memVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">call</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>defer</code> 关键字在运行期间会调用 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a>，这个函数接收了参数的大小和闭包所在的地址两个参数。</p>
<p>编译器不仅将 <code>defer</code> 关键字都转换成 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 函数，它还会通过以下三个步骤为所有调用 <code>defer</code> 的函数末尾插入 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 的函数调用：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">exit</span><span class="p">()</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Block</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   <span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasdefer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">   	<span class="o">...</span>
</span></span><span class="line"><span class="cl">   	<span class="nx">s</span><span class="p">.</span><span class="nf">rtcall</span><span class="p">(</span><span class="nx">Deferreturn</span><span class="p">,</span> <span class="kc">true</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">   <span class="p">}</span>
</span></span><span class="line"><span class="cl">   <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当运行时将 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 分配到堆上时，Go 语言的编译器不仅将 <code>defer</code> 转换成了 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a>，还在所有调用 <code>defer</code> 的函数结尾插入了 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a>。上述两个运行时函数是 <code>defer</code> 关键字运行时机制的入口，它们分别承担了不同的工作：</p>
<ul>
<li><a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 负责创建新的延迟调用；</li>
<li><a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 负责在函数调用结束时执行所有的延迟调用；</li>
</ul>
<h4 id="创建延迟调用">创建延迟调用</h4>
<p><a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 会为 <code>defer</code> 创建一个新的 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体、设置它的函数指针 <code>fn</code>、程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并将相关的参数拷贝到相邻的内存空间中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deferproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">argp</span> <span class="o">:=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">fn</span><span class="p">))</span> <span class="o">+</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Sizeof</span><span class="p">(</span><span class="nx">fn</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">callerpc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="o">:=</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;deferproc: d.panic != nil after newdefer&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">fn</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nx">callerpc</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nx">sp</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">siz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nf">memmove</span><span class="p">(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">argp</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">return0</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>最后调用的 <a href="https://draveness.me/golang/tree/runtime.return0"><code>runtime.return0</code></a> 是唯一一个不会触发延迟调用的函数，它可以避免递归 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 的递归调用。</p>
<p><a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 中 <a href="https://draveness.me/golang/tree/runtime.newdefer"><code>runtime.newdefer</code></a> 的作用是想尽办法获得 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体，这里包含三种路径：</p>
<ol>
<li>从调度器的延迟调用缓存池 <code>sched.deferpool</code> 中取出结构体并将该结构体追加到当前 Goroutine 的缓存池中；</li>
<li>从 Goroutine 的延迟调用缓存池 <code>pp.deferpool</code> 中取出结构体；</li>
<li>通过 <a href="https://draveness.me/golang/tree/runtime.mallocgc"><code>runtime.mallocgc</code></a> 在堆上创建一个新的结构体；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">newdefer</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">)</span> <span class="o">*</span><span class="nx">_defer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sc</span> <span class="o">:=</span> <span class="nf">deferclass</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">sc</span> <span class="p">&lt;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nx">p</span><span class="p">{}.</span><span class="nx">deferpool</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">pp</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">m</span><span class="p">.</span><span class="nx">p</span><span class="p">.</span><span class="nf">ptr</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span> <span class="p">&lt;</span> <span class="nb">cap</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">d</span> <span class="o">:=</span> <span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">				<span class="nx">sched</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
</span></span><span class="line"><span class="cl">				<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">],</span> <span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]);</span> <span class="nx">n</span> <span class="p">&gt;</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">d</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">			<span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pp</span><span class="p">.</span><span class="nx">deferpool</span><span class="p">[</span><span class="nx">sc</span><span class="p">][:</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">total</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nf">totaldefersize</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">siz</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_defer</span><span class="p">)(</span><span class="nf">mallocgc</span><span class="p">(</span><span class="nx">total</span><span class="p">,</span> <span class="nx">deferType</span><span class="p">,</span> <span class="kc">true</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">=</span> <span class="nx">siz</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">d</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>无论使用哪种方式，只要获取到 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体，它都会被追加到所在 Goroutine <code>_defer</code> 链表的最前面。</p>
<p><code>defer</code> 关键字的插入顺序是从后向前的，而 <code>defer</code> 关键字执行是从前向后的，这也是为什么后调用的 <code>defer</code> 会优先执行。</p>
<h4 id="执行延迟调用">执行延迟调用</h4>
<p><a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 会从 Goroutine 的 <code>_defer</code> 链表中取出最前面的 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 并调用 <a href="https://draveness.me/golang/tree/runtime.jmpdefer"><code>runtime.jmpdefer</code></a> 传入需要执行的函数和参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deferreturn</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">d</span><span class="p">.</span><span class="nx">siz</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">))</span> <span class="p">=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="k">default</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nf">memmove</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">),</span> <span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fn</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fn</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
</span></span><span class="line"><span class="cl">	<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nf">jmpdefer</span><span class="p">(</span><span class="nx">fn</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">arg0</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.jmpdefer"><code>runtime.jmpdefer</code></a> 是一个用汇编语言实现的运行时函数，它的主要工作是跳转到 <code>defer</code> 所在的代码段并在执行结束之后跳转回 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a>。</p>
<h3 id="栈上分配">栈上分配</h3>
<p>在默认情况下，我们可以看到 Go 语言中 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体都会在堆上分配，如果我们能够将部分结构体分配到栈上就可以节约内存分配带来的额外开销。当该关键字在函数体中最多执行一次时，编译期间的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.call"><code>cmd/compile/internal/gc.state.call</code></a> 会将结构体分配到栈上并调用 <a href="https://draveness.me/golang/tree/runtime.deferprocStack"><code>runtime.deferprocStack</code></a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="p">(</span><span class="nx">s</span> <span class="o">*</span><span class="nx">state</span><span class="p">)</span> <span class="nf">call</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">k</span> <span class="nx">callKind</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">call</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">k</span> <span class="o">==</span> <span class="nx">callDeferStack</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 在栈上创建 _defer 结构体
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">t</span> <span class="o">:=</span> <span class="nf">deferstruct</span><span class="p">(</span><span class="nx">stksize</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">ACArgs</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">ACArgs</span><span class="p">,</span> <span class="nx">ssa</span><span class="p">.</span><span class="nx">Param</span><span class="p">{</span><span class="nx">Type</span><span class="p">:</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINTPTR</span><span class="p">],</span> <span class="nx">Offset</span><span class="p">:</span> <span class="nb">int32</span><span class="p">(</span><span class="nx">Ctxt</span><span class="p">.</span><span class="nf">FixedFrameSize</span><span class="p">())})</span>
</span></span><span class="line"><span class="cl">		<span class="nx">aux</span> <span class="o">:=</span> <span class="nx">ssa</span><span class="p">.</span><span class="nf">StaticAuxCall</span><span class="p">(</span><span class="nx">deferprocStack</span><span class="p">,</span> <span class="nx">ACArgs</span><span class="p">,</span> <span class="nx">ACResults</span><span class="p">)</span> <span class="c1">// 调用 deferprocStack
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">arg0</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">constOffPtrSP</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINTPTR</span><span class="p">],</span> <span class="nx">Ctxt</span><span class="p">.</span><span class="nf">FixedFrameSize</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINTPTR</span><span class="p">],</span> <span class="nx">arg0</span><span class="p">,</span> <span class="nx">addr</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">call</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1A</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpStaticCall</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TypeMem</span><span class="p">,</span> <span class="nx">aux</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mem</span><span class="p">())</span>
</span></span><span class="line"><span class="cl">		<span class="nx">call</span><span class="p">.</span><span class="nx">AuxInt</span> <span class="p">=</span> <span class="nx">stksize</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">memVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">call</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>因为在编译期间我们已经创建了 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体，所以在运行期间 <a href="https://draveness.me/golang/tree/runtime.deferprocStack"><code>runtime.deferprocStack</code></a> 只需要设置一些未在编译期间初始化的字段，就可以将栈上的 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 追加到函数的链表上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deferprocStack</span><span class="p">(</span><span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">started</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">heap</span> <span class="p">=</span> <span class="kc">false</span> <span class="c1">// 栈上分配的 _defer
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">sp</span> <span class="p">=</span> <span class="nf">getcallersp</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">pc</span> <span class="p">=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">framepc</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span><span class="p">.</span><span class="nx">varp</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">fd</span><span class="p">))</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">d</span><span class="p">.</span><span class="nx">link</span><span class="p">))</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uintptr</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span><span class="p">))</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">return0</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了分配位置的不同，栈上分配和堆上分配的 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 并没有本质的不同，而该方法可以适用于绝大多数的场景，与堆上分配的 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 相比，该方法可以将 <code>defer</code> 关键字的额外开销降低 ~30%。</p>
<h3 id="开放编码">开放编码</h3>
<p>Go 语言在 1.14 中通过开放编码（Open Coded）实现 <code>defer</code> 关键字，该设计使用代码内联优化 <code>defer</code> 关键的额外开销并引入函数数据 <code>funcdata</code> 管理 <code>panic</code> 的调用，该优化可以将 <code>defer</code> 的调用开销从 1.13 版本的 ~35ns 降低至 ~6ns 左右。</p>
<p>然而开放编码作为一种优化 <code>defer</code> 关键字的方法，它不是在所有的场景下都会开启的，开放编码只会在满足以下的条件时启用：</p>
<ol>
<li>函数的 <code>defer</code> 数量少于或者等于 8 个；</li>
<li>函数的 <code>defer</code> 关键字不能在循环中执行；</li>
<li>函数的 <code>return</code> 语句与 <code>defer</code> 语句的乘积小于或者等于 15 个；</li>
</ol>
<h4 id="启用优化">启用优化</h4>
<p>Go 语言会在编译期间就确定是否启用开放编码，在编译器生成中间代码之前，我们会使用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.walkstmt"><code>cmd/compile/internal/gc.walkstmt</code></a> 修改已经生成的抽象语法树，设置函数体上的 <code>OpenCodedDeferDisallowed</code> 属性：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">const</span> <span class="nx">maxOpenDefers</span> <span class="p">=</span> <span class="mi">8</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">walkstmt</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="o">*</span><span class="nx">Node</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">switch</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Op</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="k">case</span> <span class="nx">ODEFER</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">SetHasDefer</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nx">numDefers</span><span class="o">++</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nx">numDefers</span> <span class="p">&gt;</span> <span class="nx">maxOpenDefers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">SetOpenCodedDeferDisallowed</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">Esc</span> <span class="o">!=</span> <span class="nx">EscNever</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">Curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">SetOpenCodedDeferDisallowed</span><span class="p">(</span><span class="kc">true</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="k">fallthrough</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>就像我们上面提到的，如果函数中 <code>defer</code> 关键字的数量多于 8 个或者 <code>defer</code> 关键字处于 <code>for</code> 循环中，那么我们在这里都会禁用开放编码优化，使用上两节提到的方法处理 <code>defer</code>。</p>
<p>在 SSA 中间代码生成阶段的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.buildssa"><code>cmd/compile/internal/gc.buildssa</code></a> 中，我们也能够看到启用开放编码优化的其他条件，也就是返回语句的数量与 <code>defer</code> 数量的乘积需要小于 15：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">buildssa</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">worker</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Func</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasdefer</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nf">OpenCodedDeferDisallowed</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="o">&amp;&amp;</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nx">numReturns</span><span class="o">*</span><span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">.</span><span class="nx">Func</span><span class="p">.</span><span class="nx">numDefers</span> <span class="p">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">=</span> <span class="kc">false</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>中间代码生成的这两个步骤会决定当前函数是否应该使用开放编码优化 <code>defer</code> 关键字，一旦确定使用开放编码，就会在编译期间初始化延迟比特和延迟记录。</p>
<h4 id="延迟记录">延迟记录</h4>
<p>延迟比特和延迟记录是使用开放编码实现 <code>defer</code> 的两个最重要结构，一旦决定使用开放编码，<a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.buildssa"><code>cmd/compile/internal/gc.buildssa</code></a> 会在编译期间在栈上初始化大小为 8 个比特的 <code>deferBits</code> 变量：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">buildssa</span><span class="p">(</span><span class="nx">fn</span> <span class="o">*</span><span class="nx">Node</span><span class="p">,</span> <span class="nx">worker</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Func</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">s</span><span class="p">.</span><span class="nx">hasOpenDefers</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">deferBitsTemp</span> <span class="o">:=</span> <span class="nf">tempAt</span><span class="p">(</span><span class="nx">src</span><span class="p">.</span><span class="nx">NoXPos</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nx">curfn</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">])</span> <span class="c1">// 初始化延迟比特
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">s</span><span class="p">.</span><span class="nx">deferBitsTemp</span> <span class="p">=</span> <span class="nx">deferBitsTemp</span>
</span></span><span class="line"><span class="cl">		<span class="nx">startDeferBits</span> <span class="o">:=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">entryNewValue0</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpConst8</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">])</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">deferBitsVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">startDeferBits</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">deferBitsAddr</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">addr</span><span class="p">(</span><span class="nx">deferBitsTemp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nf">store</span><span class="p">(</span><span class="nx">types</span><span class="p">.</span><span class="nx">Types</span><span class="p">[</span><span class="nx">TUINT8</span><span class="p">],</span> <span class="nx">s</span><span class="p">.</span><span class="nx">deferBitsAddr</span><span class="p">,</span> <span class="nx">startDeferBits</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">s</span><span class="p">.</span><span class="nx">vars</span><span class="p">[</span><span class="o">&amp;</span><span class="nx">memVar</span><span class="p">]</span> <span class="p">=</span> <span class="nx">s</span><span class="p">.</span><span class="nf">newValue1Apos</span><span class="p">(</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">OpVarLive</span><span class="p">,</span> <span class="nx">types</span><span class="p">.</span><span class="nx">TypeMem</span><span class="p">,</span> <span class="nx">deferBitsTemp</span><span class="p">,</span> <span class="nx">s</span><span class="p">.</span><span class="nf">mem</span><span class="p">(),</span> <span class="kc">false</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>延迟比特中的每一个比特位都表示该位对应的 <code>defer</code> 关键字是否需要被执行。</p>
<p>因为不是函数中所有的 <code>defer</code> 语句都会在函数返回前执行，如下所示的代码只会在 <code>if</code> 语句的条件为真时，其中的 <code>defer</code> 语句才会在结尾被执行</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="nx">deferBits</span> <span class="o">:=</span> <span class="mi">0</span> <span class="c1">// 初始化 deferBits
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="nx">_f1</span><span class="p">,</span> <span class="nx">_a1</span> <span class="o">:=</span> <span class="nx">f1</span><span class="p">,</span> <span class="nx">a1</span>  <span class="c1">// 保存函数以及参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="nx">deferBits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="c1">// 将 deferBits 最后一位置位 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">condition</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">_f2</span><span class="p">,</span> <span class="nx">_a2</span> <span class="o">:=</span> <span class="nx">f2</span><span class="p">,</span> <span class="nx">a2</span>  <span class="c1">// 保存函数以及参数
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>    <span class="nx">deferBits</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="c1">// 将 deferBits 倒数第二位置位 1
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="p">}</span>
</span></span><span class="line"><span class="cl"><span class="nx">exit</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">deferBits</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">deferBits</span> <span class="o">&amp;^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_f2</span><span class="p">(</span><span class="nx">a2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">if</span> <span class="nx">deferBits</span> <span class="o">&amp;</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">    <span class="nx">deferBits</span> <span class="o">&amp;^=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">    <span class="nf">_f1</span><span class="p">(</span><span class="nx">a1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>延迟比特的作用就是标记哪些 <code>defer</code> 关键字在函数中被执行，这样在函数返回时可以根据对应 <code>deferBits</code> 的内容确定执行的函数，而正是因为 <code>deferBits</code> 的大小仅为 8 比特，所以该优化的启用条件为函数中的 <code>defer</code> 关键字少于 8 个。</p>
<p>上述伪代码展示了开放编码的实现原理，但是仍然缺少了一些细节，例如：传入 <code>defer</code> 关键字的函数和参数都会存储在如下所示的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.openDeferInfo"><code>cmd/compile/internal/gc.openDeferInfo</code></a> 结构体中：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">type</span> <span class="nx">openDeferInfo</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">n</span>           <span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl">	<span class="nx">closure</span>     <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">closureNode</span> <span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rcvr</span>        <span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">rcvrNode</span>    <span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl">	<span class="nx">argVals</span>     <span class="p">[]</span><span class="o">*</span><span class="nx">ssa</span><span class="p">.</span><span class="nx">Value</span>
</span></span><span class="line"><span class="cl">	<span class="nx">argNodes</span>    <span class="p">[]</span><span class="o">*</span><span class="nx">Node</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当编译器在调用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.buildssa"><code>cmd/compile/internal/gc.buildssa</code></a> 构建中间代码时会通过 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.openDeferRecord"><code>cmd/compile/internal/gc.state.openDeferRecord</code></a> 方法在栈上构建结构体，该结构体的 <code>closure</code> 中存储着调用的函数，<code>rcvr</code> 中存储着方法的接收者，而最后的 <code>argVals</code> 中存储了函数的参数。</p>
<p>很多 <code>defer</code> 语句都可以在编译期间判断是否被执行，如果函数中的 <code>defer</code> 语句都会在编译期间确定，中间代码生成阶段就会直接调用 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.openDeferExit"><code>cmd/compile/internal/gc.state.openDeferExit</code></a> 在函数返回前生成判断 <code>deferBits</code> 的代码，也就是上述伪代码中的后半部分。</p>
<p>不过当程序遇到运行时才能判断的条件语句时，我们仍然需要由运行时的 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 决定是否执行 <code>defer</code> 关键字：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deferreturn</span><span class="p">(</span><span class="nx">arg0</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">d</span><span class="p">.</span><span class="nx">openDefer</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">runOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
</span></span><span class="line"><span class="cl">		<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数为开放编码做了特殊的优化，运行时会调用 <a href="https://draveness.me/golang/tree/runtime.runOpenDeferFrame"><code>runtime.runOpenDeferFrame</code></a> 执行活跃的开放编码延迟函数，该函数会执行以下的工作：</p>
<ol>
<li>从 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体中读取 <code>deferBits</code>、函数 <code>defer</code> 数量等信息；</li>
<li>在循环中依次读取函数的地址和参数信息并通过 <code>deferBits</code> 判断该函数是否需要被执行；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.reflectcallSave"><code>runtime.reflectcallSave</code></a> 调用需要执行的 <code>defer</code> 函数；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">runOpenDeferFrame</span><span class="p">(</span><span class="nx">gp</span> <span class="o">*</span><span class="nx">g</span><span class="p">,</span> <span class="nx">d</span> <span class="o">*</span><span class="nx">_defer</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">fd</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">fd</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nx">deferBitsOffset</span><span class="p">,</span> <span class="nx">fd</span> <span class="o">:=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">nDefers</span><span class="p">,</span> <span class="nx">fd</span> <span class="o">:=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">deferBits</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint8</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">varp</span> <span class="o">-</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">deferBitsOffset</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nDefers</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span><span class="o">--</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="kd">var</span> <span class="nx">argWidth</span><span class="p">,</span> <span class="nx">closureOffset</span><span class="p">,</span> <span class="nx">nArgs</span> <span class="kt">uint32</span> <span class="c1">// 读取函数的地址和参数信息
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="nx">argWidth</span><span class="p">,</span> <span class="nx">fd</span> <span class="p">=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">closureOffset</span><span class="p">,</span> <span class="nx">fd</span> <span class="p">=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nx">nArgs</span><span class="p">,</span> <span class="nx">fd</span> <span class="p">=</span> <span class="nf">readvarintUnsafe</span><span class="p">(</span><span class="nx">fd</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">deferBits</span><span class="o">&amp;</span><span class="p">(</span><span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">i</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">...</span>
</span></span><span class="line"><span class="cl">			<span class="k">continue</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">closure</span> <span class="o">:=</span> <span class="o">*</span><span class="p">(</span><span class="o">**</span><span class="nx">funcval</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">varp</span> <span class="o">-</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">closureOffset</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="nx">closure</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">deferBits</span> <span class="p">=</span> <span class="nx">deferBits</span> <span class="o">&amp;^</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">i</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">uint8</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">varp</span> <span class="o">-</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">deferBitsOffset</span><span class="p">)))</span> <span class="p">=</span> <span class="nx">deferBits</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span>
</span></span><span class="line"><span class="cl">		<span class="nf">reflectcallSave</span><span class="p">(</span><span class="nx">p</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">closure</span><span class="p">),</span> <span class="nx">deferArgs</span><span class="p">,</span> <span class="nx">argWidth</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">p</span><span class="p">.</span><span class="nx">aborted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">deferArgs</span><span class="p">,</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">argWidth</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="nx">done</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="总结">总结</h3>
<p>三种机制：</p>
<ul>
<li>堆上分配 · 1.1 ~ 1.12
<ul>
<li>编译期将 <code>defer</code> 关键字转换成 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 并在调用 <code>defer</code> 关键字的函数返回之前插入 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a>；</li>
<li>运行时调用 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 会将一个新的 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体追加到当前 Goroutine 的链表头；</li>
<li>运行时调用 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 会从 Goroutine 的链表中取出 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构并依次执行；</li>
</ul>
</li>
<li>栈上分配 · 1.13
<ul>
<li>当该关键字在函数体中最多执行一次时，编译期间的 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.state.call"><code>cmd/compile/internal/gc.state.call</code></a> 会将结构体分配到栈上并调用 <a href="https://draveness.me/golang/tree/runtime.deferprocStack"><code>runtime.deferprocStack</code></a>；</li>
</ul>
</li>
<li>开放编码 · 1.14 ~ 现在
<ul>
<li>编译期间判断 <code>defer</code> 关键字、<code>return</code> 语句的个数确定是否开启开放编码优化；</li>
<li>通过 <code>deferBits</code> 和 <a href="https://draveness.me/golang/tree/cmd/compile/internal/gc.openDeferInfo"><code>cmd/compile/internal/gc.openDeferInfo</code></a> 存储 <code>defer</code> 关键字的相关信息；</li>
<li>如果 <code>defer</code> 关键字的执行可以在编译期间确定，会在函数返回前直接插入相应的代码，否则会由运行时的 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 处理；</li>
</ul>
</li>
</ul>
<h2 id="paincrecovery">painc&amp;&amp;recovery</h2>
<ul>
<li><code>panic</code> 能够改变程序的控制流，调用 <code>panic</code> 后会立刻停止执行当前函数的剩余代码，并在当前 Goroutine 中递归执行调用方的 <code>defer</code>；</li>
<li><code>recover</code> 可以中止 <code>panic</code> 造成的程序崩溃。它是一个只能在 <code>defer</code> 中发挥作用的函数，在其他作用域中调用不会发挥作用；</li>
</ul>
<h3 id="现象">现象</h3>
<ul>
<li><code>panic</code> 只会触发当前 Goroutine 的 <code>defer</code>；</li>
<li><code>recover</code> 只有在 <code>defer</code> 中调用才会生效；</li>
<li><code>panic</code> 允许在 <code>defer</code> 中嵌套多次调用；</li>
</ul>
<p>如果代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kn">package</span> <span class="nx">main</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="p">(</span>
</span></span><span class="line"><span class="cl">	<span class="s">&#34;time&#34;</span>
</span></span><span class="line"><span class="cl"><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">  <span class="nb">println</span><span class="p">(</span><span class="s">&#34;start main&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">defer</span> <span class="nb">println</span><span class="p">(</span><span class="s">&#34;in main&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="nx">testChan</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">select</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">case</span> <span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="o">&lt;-</span><span class="nx">testChan</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">				<span class="nb">println</span><span class="p">(</span><span class="nx">val</span><span class="p">,</span> <span class="nx">ok</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">	<span class="k">go</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="k">defer</span> <span class="nb">println</span><span class="p">(</span><span class="s">&#34;in goroutine&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nb">panic</span><span class="p">(</span><span class="s">&#34;&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="mi">1</span> <span class="o">*</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>设置一个env：<code>GOTRACEBACK=1</code></p>
<p>官方解释：</p>
<blockquote>
<p>The GOTRACEBACK variable controls the amount of output generated when a Go program fails due to an unrecovered panic or an unexpected runtime condition. <code>By default, a failure prints a stack trace for the current goroutine</code>, eliding functions internal to the run-time system, and then exits with exit code 2. The failure prints stack traces for all goroutines if there is no current goroutine or the failure is internal to the run-time. <code>GOTRACEBACK=none omits the goroutine stack traces entirely</code>. <code>GOTRACEBACK=single (the default) behaves as described above.</code> <code>GOTRACEBACK=all adds stack traces for all user-created goroutines</code>. <code>GOTRACEBACK=system is like “all” but adds stack frames for run-time functions and shows goroutines created internally by the run-time</code>. <code>GOTRACEBACK=crash is like “system” but crashes in an operating system-specific manner instead of exiting.</code> For example, on Unix systems, the crash raises SIGABRT to trigger a core dump. For historical reasons, the GOTRACEBACK settings 0, 1, and 2 are synonyms for none, all, and system, respectively. The runtime/debug package&rsquo;s SetTraceback function allows increasing the amount of output at run time, but it cannot reduce the amount below that specified by the environment variable.</p>
</blockquote>
<p>也就是GOTRACEBACK可以有如下取值：</p>
<ul>
<li>none(0)：屏蔽崩溃的栈输出</li>
<li>single(默认值)：只输出当前goroutine的栈</li>
<li>all(1)：输出所有用户创建的goroutines的栈</li>
<li>system(2)：除了all，还有一些系统级别的goroutines，例如垃圾回收goroutine</li>
<li>crash：除了system的输出，还可以包括core文件，可以用于定位问题</li>
</ul>
<p>则其输出为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">start main
</span></span><span class="line"><span class="cl">in goroutine
</span></span><span class="line"><span class="cl">panic: 
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">goroutine 6 [running]:
</span></span><span class="line"><span class="cl">main.main.func2()
</span></span><span class="line"><span class="cl">        /Users/hxsup/go/src/github.com/hTangle/test-go/main.go:20 +0x7b
</span></span><span class="line"><span class="cl">created by main.main
</span></span><span class="line"><span class="cl">        /Users/hxsup/go/src/github.com/hTangle/test-go/main.go:18 +0xd3
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">goroutine 1 [sleep]:
</span></span><span class="line"><span class="cl">time.Sleep(0x3b9aca00)
</span></span><span class="line"><span class="cl">        /usr/local/go/src/runtime/time.go:193 +0x12e
</span></span><span class="line"><span class="cl">main.main()
</span></span><span class="line"><span class="cl">        /Users/hxsup/go/src/github.com/hTangle/test-go/main.go:23 +0xdd
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">goroutine 5 [chan receive]:
</span></span><span class="line"><span class="cl">main.main.func1()
</span></span><span class="line"><span class="cl">        /Users/hxsup/go/src/github.com/hTangle/test-go/main.go:13 +0x27
</span></span><span class="line"><span class="cl">created by main.main
</span></span><span class="line"><span class="cl">        /Users/hxsup/go/src/github.com/hTangle/test-go/main.go:10 +0xc5
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，函数执行了go函数中的defer函数，但是没有执行main中的defer函数，说明<code>panic</code> 只会触发当前 Goroutine 的 <code>defer</code>。</p>
<h3 id="panic数据结构">panic数据结构</h3>
<p><code>panic</code> 关键字在 Go 语言的源代码是由数据结构 <a href="https://draveness.me/golang/tree/runtime._panic"><code>runtime._panic</code></a> 表示的。每当我们调用 <code>panic</code> 都会创建一个如下所示的数据结构存储相关信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="c1">// A _panic holds information about an active panic.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// A _panic value must only ever live on the stack.
</span></span></span><span class="line"><span class="cl"><span class="c1">//
</span></span></span><span class="line"><span class="cl"><span class="c1">// The argp and link fields are stack pointers, but don&#39;t need special
</span></span></span><span class="line"><span class="cl"><span class="c1">// handling during stack growth: because they are pointer-typed and
</span></span></span><span class="line"><span class="cl"><span class="c1">// _panic values only live on the stack, regular stack pointer
</span></span></span><span class="line"><span class="cl"><span class="c1">// adjustment takes care of them.
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kd">type</span> <span class="nx">_panic</span> <span class="kd">struct</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">argp</span>      <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// pointer to arguments of deferred call run during panic; cannot move - known to liblink
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">arg</span>       <span class="kd">interface</span><span class="p">{}</span>    <span class="c1">// argument to panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">link</span>      <span class="o">*</span><span class="nx">_panic</span>        <span class="c1">// link to earlier panic
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">pc</span>        <span class="kt">uintptr</span>        <span class="c1">// where to return to in runtime if this panic is bypassed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">sp</span>        <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// where to return to in runtime if this panic is bypassed
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">recovered</span> <span class="kt">bool</span>           <span class="c1">// whether this panic is over
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">aborted</span>   <span class="kt">bool</span>           <span class="c1">// the panic was aborted
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>	<span class="nx">goexit</span>    <span class="kt">bool</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ol>
<li><code>argp</code> 是指向 <code>defer</code> 调用时参数的指针；</li>
<li><code>arg</code> 是调用 <code>panic</code> 时传入的参数；</li>
<li><code>link</code> 指向了更早调用的 <a href="https://draveness.me/golang/tree/runtime._panic"><code>runtime._panic</code></a> 结构；</li>
<li><code>recovered</code> 表示当前 <a href="https://draveness.me/golang/tree/runtime._panic"><code>runtime._panic</code></a> 是否被 <code>recover</code> 恢复；</li>
<li><code>aborted</code> 表示当前的 <code>panic</code> 是否被强行终止；</li>
</ol>
<p>从数据结构中的 <code>link</code> 字段我们就可以推测出以下的结论：<code>panic</code> 函数可以被连续多次调用，它们之间通过 <code>link</code> 可以组成链表。</p>
<p>结构体中的 <code>pc</code>、<code>sp</code> 和 <code>goexit</code> 三个字段都是为了修复 <a href="https://draveness.me/golang/tree/runtime.Goexit"><code>runtime.Goexit</code></a> 带来的问题引入的。<a href="https://draveness.me/golang/tree/runtime.Goexit"><code>runtime.Goexit</code></a> 能够只结束调用该函数的 Goroutine 而不影响其他的 Goroutine，但是该函数会被 <code>defer</code> 中的 <code>panic</code> 和 <code>recover</code> 取消，引入这三个字段就是为了保证该函数的一定会生效。</p>
<h3 id="程序崩溃">程序崩溃</h3>
<p>编译器会将关键字 <code>panic</code> 转换成 <a href="https://draveness.me/golang/tree/runtime.gopanic"><code>runtime.gopanic</code></a>，该函数的执行过程包含以下几个步骤：</p>
<ol>
<li>创建新的 <a href="https://draveness.me/golang/tree/runtime._panic"><code>runtime._panic</code></a> 并添加到所在 Goroutine 的 <code>_panic</code> 链表的最前面；</li>
<li>在循环中不断从当前 Goroutine 的 <code>_defer</code> 中链表获取 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 并调用 <a href="https://draveness.me/golang/tree/runtime.reflectcall"><code>runtime.reflectcall</code></a> 运行延迟调用函数；</li>
<li>调用 <a href="https://draveness.me/golang/tree/runtime.fatalpanic"><code>runtime.fatalpanic</code></a> 中止整个程序；</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gopanic</span><span class="p">(</span><span class="nx">e</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="kd">var</span> <span class="nx">p</span> <span class="nx">_panic</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nx">arg</span> <span class="p">=</span> <span class="nx">e</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span><span class="p">.</span><span class="nx">link</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_panic</span><span class="p">)(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">d</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="k">break</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">_panic</span><span class="p">)(</span><span class="nf">noescape</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">p</span><span class="p">)))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">reflectcall</span><span class="p">(</span><span class="kc">nil</span><span class="p">,</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">fn</span><span class="p">),</span> <span class="nf">deferArgs</span><span class="p">(</span><span class="nx">d</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">),</span> <span class="nb">uint32</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">siz</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="nx">d</span><span class="p">.</span><span class="nx">fn</span> <span class="p">=</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl">		<span class="nx">gp</span><span class="p">.</span><span class="nx">_defer</span> <span class="p">=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">link</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nf">freedefer</span><span class="p">(</span><span class="nx">d</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="o">...</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">fatalpanic</span><span class="p">(</span><span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="kt">int</span><span class="p">)(</span><span class="kc">nil</span><span class="p">)</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://draveness.me/golang/tree/runtime.fatalpanic"><code>runtime.fatalpanic</code></a> 实现了无法被恢复的程序崩溃，它在中止程序之前会通过 <a href="https://draveness.me/golang/tree/runtime.printpanics"><code>runtime.printpanics</code></a> 打印出全部的 <code>panic</code> 消息以及调用时传入的参数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">fatalpanic</span><span class="p">(</span><span class="nx">msgs</span> <span class="o">*</span><span class="nx">_panic</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">pc</span> <span class="o">:=</span> <span class="nf">getcallerpc</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">sp</span> <span class="o">:=</span> <span class="nf">getcallersp</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">startpanic_m</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="nx">msgs</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">atomic</span><span class="p">.</span><span class="nf">Xadd</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">runningPanicDefers</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="nf">printpanics</span><span class="p">(</span><span class="nx">msgs</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nf">dopanic_m</span><span class="p">(</span><span class="nx">gp</span><span class="p">,</span> <span class="nx">pc</span><span class="p">,</span> <span class="nx">sp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nf">crash</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="nf">exit</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>打印崩溃消息后会调用 <a href="https://draveness.me/golang/tree/runtime.exit"><code>runtime.exit</code></a> 退出当前程序并返回错误码 2，程序的正常退出也是通过 <a href="https://draveness.me/golang/tree/runtime.exit"><code>runtime.exit</code></a> 实现的。</p>
<h3 id="崩溃恢复">崩溃恢复</h3>
<p>编译器会将关键字 <code>recover</code> 转换成 <a href="https://draveness.me/golang/tree/runtime.gorecover"><code>runtime.gorecover</code></a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gorecover</span><span class="p">(</span><span class="nx">argp</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="nx">gp</span> <span class="o">:=</span> <span class="nf">getg</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">	<span class="nx">p</span> <span class="o">:=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span>
</span></span><span class="line"><span class="cl">	<span class="k">if</span> <span class="nx">p</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="p">!</span><span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span> <span class="o">&amp;&amp;</span> <span class="nx">argp</span> <span class="o">==</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">p</span><span class="p">.</span><span class="nx">argp</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span> <span class="p">=</span> <span class="kc">true</span>
</span></span><span class="line"><span class="cl">		<span class="k">return</span> <span class="nx">p</span><span class="p">.</span><span class="nx">arg</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="k">return</span> <span class="kc">nil</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该函数的实现很简单，如果当前 Goroutine 没有调用 <code>panic</code>，那么该函数会直接返回 <code>nil</code>，这也是崩溃恢复在非 <code>defer</code> 中调用会失效的原因。在正常情况下，它会修改 <a href="https://draveness.me/golang/tree/runtime._panic"><code>runtime._panic</code></a> 的 <code>recovered</code> 字段，<a href="https://draveness.me/golang/tree/runtime.gorecover"><code>runtime.gorecover</code></a> 函数中并不包含恢复程序的逻辑，程序的恢复是由 <a href="https://draveness.me/golang/tree/runtime.gopanic"><code>runtime.gopanic</code></a> 函数负责的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">gopanic</span><span class="p">(</span><span class="nx">e</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">	<span class="k">for</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">		<span class="c1">// 执行延迟调用函数，可能会设置 p.recovered = true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span>		<span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="nx">pc</span> <span class="o">:=</span> <span class="nx">d</span><span class="p">.</span><span class="nx">pc</span>
</span></span><span class="line"><span class="cl">		<span class="nx">sp</span> <span class="o">:=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">d</span><span class="p">.</span><span class="nx">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">		<span class="o">...</span>
</span></span><span class="line"><span class="cl">		<span class="k">if</span> <span class="nx">p</span><span class="p">.</span><span class="nx">recovered</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">			<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="nx">p</span><span class="p">.</span><span class="nx">link</span>
</span></span><span class="line"><span class="cl">			<span class="k">for</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">aborted</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="p">=</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span><span class="p">.</span><span class="nx">link</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="k">if</span> <span class="nx">gp</span><span class="p">.</span><span class="nx">_panic</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">				<span class="nx">gp</span><span class="p">.</span><span class="nx">sig</span> <span class="p">=</span> <span class="mi">0</span>
</span></span><span class="line"><span class="cl">			<span class="p">}</span>
</span></span><span class="line"><span class="cl">			<span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode0</span> <span class="p">=</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">sp</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nx">gp</span><span class="p">.</span><span class="nx">sigcode1</span> <span class="p">=</span> <span class="nx">pc</span>
</span></span><span class="line"><span class="cl">			<span class="nf">mcall</span><span class="p">(</span><span class="nx">recovery</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">			<span class="nf">throw</span><span class="p">(</span><span class="s">&#34;recovery failed&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">		<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="p">}</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>当我们在调用 <code>defer</code> 关键字时，调用时的栈指针 <code>sp</code> 和程序计数器 <code>pc</code> 就已经存储到了 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体中，这里的 <a href="https://draveness.me/golang/tree/runtime.gogo"><code>runtime.gogo</code></a> 函数会跳回 <code>defer</code> 关键字调用的位置。</p>
<p><a href="https://draveness.me/golang/tree/runtime.recovery"><code>runtime.recovery</code></a> 在调度过程中会将函数的返回值设置成 1。从 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 的注释中我们会发现，当 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 函数的返回值是 1 时，编译器生成的代码会直接跳转到调用方函数返回之前并执行 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="line"><span class="cl"><span class="kd">func</span> <span class="nf">deferproc</span><span class="p">(</span><span class="nx">siz</span> <span class="kt">int32</span><span class="p">,</span> <span class="nx">fn</span> <span class="o">*</span><span class="nx">funcval</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl">	<span class="o">...</span>
</span></span><span class="line"><span class="cl">	<span class="nf">return0</span><span class="p">()</span>
</span></span><span class="line"><span class="cl"><span class="p">}</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>跳转到 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 函数之后，程序就已经从 <code>panic</code> 中恢复了并执行正常的逻辑，而 <a href="https://draveness.me/golang/tree/runtime.gorecover"><code>runtime.gorecover</code></a> 函数也能从 <a href="https://draveness.me/golang/tree/runtime._panic"><code>runtime._panic</code></a> 结构中取出了调用 <code>panic</code> 时传入的 <code>arg</code> 参数并返回给调用方。</p>
<h3 id="总结-1">总结</h3>
<ol>
<li>编译器会负责做转换关键字的工作；
<ol>
<li>将 <code>panic</code> 和 <code>recover</code> 分别转换成 <a href="https://draveness.me/golang/tree/runtime.gopanic"><code>runtime.gopanic</code></a> 和 <a href="https://draveness.me/golang/tree/runtime.gorecover"><code>runtime.gorecover</code></a>；</li>
<li>将 <code>defer</code> 转换成 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 函数；</li>
<li>在调用 <code>defer</code> 的函数末尾调用 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 函数；</li>
</ol>
</li>
<li>在运行过程中遇到 <a href="https://draveness.me/golang/tree/runtime.gopanic"><code>runtime.gopanic</code></a> 方法时，会从 Goroutine 的链表依次取出 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体并执行；</li>
<li>如果调用延迟执行函数时遇到了 <code>runtime.gorecover</code>就会将<code>_panic.recovered</code>标记成 true 并返回<code>panic</code>的参数；
<ol>
<li>在这次调用结束之后，<a href="https://draveness.me/golang/tree/runtime.gopanic"><code>runtime.gopanic</code></a> 会从 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a> 结构体中取出程序计数器 <code>pc</code> 和栈指针 <code>sp</code> 并调用 <a href="https://draveness.me/golang/tree/runtime.recovery"><code>runtime.recovery</code></a> 函数进行恢复程序；</li>
<li><a href="https://draveness.me/golang/tree/runtime.recovery"><code>runtime.recovery</code></a> 会根据传入的 <code>pc</code> 和 <code>sp</code> 跳转回 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a>；</li>
<li>编译器自动生成的代码会发现 <a href="https://draveness.me/golang/tree/runtime.deferproc"><code>runtime.deferproc</code></a> 的返回值不为 0，这时会跳回 <a href="https://draveness.me/golang/tree/runtime.deferreturn"><code>runtime.deferreturn</code></a> 并恢复到正常的执行流程；</li>
</ol>
</li>
<li>如果没有遇到 <a href="https://draveness.me/golang/tree/runtime.gorecover"><code>runtime.gorecover</code></a> 就会依次遍历所有的 <a href="https://draveness.me/golang/tree/runtime._defer"><code>runtime._defer</code></a>，并在最后调用 <a href="https://draveness.me/golang/tree/runtime.fatalpanic"><code>runtime.fatalpanic</code></a> 中止程序、打印 <code>panic</code> 的参数并返回错误码 2；</li>
</ol>
<p>参考链接：</p>
<ul>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-panic-recover/">Go 语言 panic 和 recover 的原理 | Go 语言设计与实现 (draveness.me)</a></li>
<li><a href="https://draveness.me/golang/docs/part2-foundation/ch05-keyword/golang-defer/">理解 Go 语言 defer 关键字的原理 | Go 语言设计与实现 (draveness.me)</a></li>
</ul>

    </div>

    <div class="post-copyright">
  <p class="copyright-item">
    <span class="item-title">Author</span>
    <span class="item-content">hlday</span>
  </p>
  <p class="copyright-item">
    <span class="item-title">LastMod</span>
    <span class="item-content">
        2022-06-24
        
    </span>
  </p>
  
  
</div>
<footer class="post-footer">
      <div class="post-tags">
          <a href="/tags/go/">go</a>
          </div>
      <nav class="post-nav">
        <a class="prev" href="/post/golang/incorrect-synchronization/">
            <i class="iconfont icon-left"></i>
            <span class="prev-text nav-default">Go中的错误的懒汉式双重检测单例编程模式带来的思考</span>
            <span class="prev-text nav-mobile">Prev</span>
          </a>
        <a class="next" href="/post/golang/go-open-editor/">
            <span class="next-text nav-default">Go调用系统编辑器编辑文件</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        

  

  
    <script src="https://utteranc.es/client.js"
            repo="hTangle/hxsup-blog-image"
            issue-term="pathname"
            theme="github-light"
            crossorigin="anonymous"
            async>
    </script>
    <style>
      utterances {
        max-width: 75%;
        width: 1200px;
      }
    </style>
    <noscript>Please enable JavaScript to view the <a href="https://github.com/utterance">comments powered by utterances.</a></noscript>
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <link href="https://cdn.staticfile.org/bootstrap/5.0.2/css/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous">
<script src="https://cdn.staticfile.org/bootstrap/5.0.2/js/bootstrap.min.js" crossorigin="anonymous"></script>
<style>
  .modal {
    display: none;
     
    position: fixed;
     
    z-index: 1000;
     
    padding-top: 100px;
     
    left: 0;
    top: 0;
    width: 100%;
     
    height: 100%;
     
    overflow: auto;
     
    background-color: #FFFFFF;
     
    background-color: rgba(255, 255,255, 0.98);
     
  }

   
  .modal-content {
    margin: auto;
    display: block;
  }

   
  .modal-content,
  #caption {
    animation-name: zoom;
    animation-duration: 0.6s;
  }

  @keyframes zoom {
    from {
      transform: scale(0)
    }

    to {
      transform: scale(1)
    }
  }
  .image-show-center {
    display: block !important;
    margin: 0 auto;
    border: 0;
    border-radius: 5px;
     
  }
</style>
<div id="myModal" class="modal" onclick="disShowImage()">
  <img class="modal-content" id="img01" onmousewheel="return zoomImg(this)"
       style="width: auto;height: auto;max-width: 100%;max-height: 100%;">
</div>
<script type="text/javascript">
  var modal = document.getElementById("myModal");
  var modalImg = document.getElementById("img01");
  
  function disShowImage() {
    modal.style.display = "none";
  }
  function zoomImg(obj) {
    
    let zoom = parseInt(obj.style.zoom, 10) || 100;
    
    zoom += event.wheelDelta / 12;
    if (zoom > 0) {
      obj.style.zoom = zoom + '%';
    }
    return false;
  }
  $(function () {
    console.log("init")
    var imgs=$("img");
    for(var i=0;i<imgs.length;i++){
      imgs[i].className="image-show-center rounded";
    }
    
    $("img").on('click', function () {
      console.log("test---", $(this).attr("src"))
      modal.style.display = "block";
      modalImg.style.zoom = "reset";
      modalImg.src = $(this).attr("src");
      imageClicked = true;
    })
    
  })
</script>

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="hsup1994@hotmail.com" class="iconfont icon-email" title="email"></a>
      <a href="https://github.com/hTangle" class="iconfont icon-github" title="github"></a>
  <a href="/index.xml" type="application/rss+xml" class="iconfont icon-rss" title="rss"></a>
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  <div class="busuanzi-footer">
    <span id="busuanzi_container_site_pv"> site pv: <span id="busuanzi_value_site_pv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
      <span class="division">|</span>
    <span id="busuanzi_container_site_uv"> site uv: <span id="busuanzi_value_site_uv"><img src="/img/spinner.svg" alt="spinner.svg"/></span> </span>
  </div>

  <span class="copyright-year">
    &copy; 
    2022 - 
    2023<span class="heart"><i class="iconfont icon-heart"></i></span><span><a href="/">hlday</a></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  
  <script src="https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js" integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js" integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin="anonymous"></script>
  



<script type="text/javascript" src="/js/main.min.bfb94e1fe4773651a6fe907d388ed08d7d6f9628a062d0740d992e1dfb49466e.js"></script>
  <script type="text/javascript">
    window.MathJax = {
      tex: {
        inlineMath: [['$','$'], ['\\(','\\)']],
        }
    };
  </script>
  <script async src="https://cdn.jsdelivr.net/npm/mathjax@3.0.5/es5/tex-mml-chtml.js" integrity="sha256-HGLuEfFcsUJGhvB8cQ8nr0gai9EucOOaIxFw7qxmd+w=" crossorigin="anonymous"></script>








</body>
</html>
